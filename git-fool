#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper;
use Cwd;
use Getopt::Long;
use POSIX;
use Term::ReadKey;
use File::Path;
use Term::ReadLine;


# debug stuff
my $DEBUG_NONE  = 0;
my $DEBUG_LOW   = 1;
my $DEBUG_MED   = 2;
my $DEBUG_HIGH  = 3;
my $DEBUG       = $DEBUG_NONE;


# some possibly necessary global variables (because of performance only filled when needed!)
my $mainPath          = "";         # git repository main path (where .git can be found)
my $foolPath          = "";         # $mainPath/.fool
my $userPath          = "";         # $foolPath/<user>  (= $mainPath/.fool/<user>)

my $userFile          = "";         # $userPath/<email> (= $mainPath/.fool/<user>/<email>)
my $issuesFile        = "";         # $foolPath/issues (= $mainPath/.fool/issues)

my $checkout          = "";         # current checkout

my $userName          = "";         # user.name
my $shortUserName     = "";         # first two characters of user.name (necessary for files and directories but not for issue file entry!)
my $email             = "";         # user.email
my $editor            = "";         # core.editor


# for cmd handling
my %cmd = ("init"      => \&initCmd,           # $cmd{"init"}->(...)
           "new"       => \&newCmd,
           "grep"      => \&grepCmd,
           "ls"        => \&lsCmd,
           "edit"      => \&editCmd,
           "cp"        => \&cpCmd,
           "mv"        => \&mvCmd,
           "state"     => \&stateCmd,
           "close"     => \&closeCmd,
           "reopen"    => \&reopenCmd,
           "rm"        => \&rmCmd,
           "milestone" => \&milestoneCmd,
           "help"      => \&helpCmd,
           "dummy"     => \&dummyCmd,
          );


# define file names
my $FILE_NAME_ISSUES        = 0;
my $FILE_NAME_TEMP          = 1;
my $FILE_NAME_CERTAIN_ISSUE = 2;
my $FILE_NAME_CURRENT_ISSUE = 3;
my $FILE_NAME_USER          = 4;
my $FILE_NAME_BACKUP        = 5;
my %FILE_NAMES = ( $FILE_NAME_ISSUES            =>    "issues",        # to store all the issues (but not comments, they are stored within comment/HISTORY file)
                   $FILE_NAME_TEMP              =>    ".temp",         # for editing comments from comment/HISTORY file
                   $FILE_NAME_CERTAIN_ISSUE     =>    "",              # to be filled during runtime, user name and email are necessary that are not known atm.
                   $FILE_NAME_CURRENT_ISSUE     =>    "",              # to be filled during runtime, user name and email are necessary that are not known atm.
                   $FILE_NAME_USER              =>    "",              # to be filled during runtime, user name and email are necessary that are not known atm.
                   $FILE_NAME_BACKUP            =>    ".backup",       #
                  );



# define history file sections
my $HISTORY_FILE_SECTION_NONE    = 0;
my $HISTORY_FILE_SECTION_HISTORY = 1;
my $HISTORY_FILE_SECTION_BACKUP  = 2;
my %HISTORY_FILE_SECTIONS = ( $HISTORY_FILE_SECTION_NONE      =>  "none",
                              $HISTORY_FILE_SECTION_HISTORY   =>  "[HISTORY]",
                              $HISTORY_FILE_SECTION_BACKUP    =>  "[ISSUE_BACKUP]",
                           );



# define history tokens
my $HISTORY_TOKEN_CREATED   = 0;
my $HISTORY_TOKEN_COPIED    = 1;
my $HISTORY_TOKEN_CHANGED   = 2;
my $HISTORY_TOKEN_CLOSED    = 3;
my $HISTORY_TOKEN_REOPENED  = 4;
my $HISTORY_TOKEN_REPAIRED  = 5;
my $HISTORY_TOKEN_MOVEDTO   = 6;
my $HISTORY_TOKEN_MOVEDFROM = 7;
my $HISTORY_TOKEN_UNKNOWN   = 0xFF;
my %HISTORY_TOKENS = ( $HISTORY_TOKEN_CREATED    =>  "CREATED:     ",   # usually first entry in history file
                       $HISTORY_TOKEN_COPIED     =>  "COPIED:      ",   # if this exists in history file it's usually the first entry because it's a copy of another issue
                       $HISTORY_TOKEN_CHANGED    =>  "CHANGED:     ",
                       $HISTORY_TOKEN_CLOSED     =>  "CLOSED:      ",
                       $HISTORY_TOKEN_REOPENED   =>  "REOPENED:    ",
                       $HISTORY_TOKEN_REPAIRED   =>  "REPAIRED:    ",   # if this exists in history file it's usually the first entry because original file has been lost
                       $HISTORY_TOKEN_MOVEDTO    =>  "MOVED_TO:    ",
                       $HISTORY_TOKEN_MOVEDFROM  =>  "MOVED_FROM:  ",   # if this exists in history file it's usually the first entry because it's a copy of another issue (original one has been closed during move process!)
                       $HISTORY_TOKEN_UNKNOWN    =>  "UNKNOWN:     ",
                     );


# defined issue types
my $ISSUE_TYPE_TASK     = 0;
my $ISSUE_TYPE_BUG      = 1;
my $ISSUE_TYPE_NOTE     = 2;
my $ISSUE_TYPE_DEFAULT  = $ISSUE_TYPE_TASK;
# no duplicated issues here and no gaps between the issues!!!
my %ISSUE_TYPES = ( $ISSUE_TYPE_TASK    => "Task",
                    $ISSUE_TYPE_BUG     => "Bug",
                    $ISSUE_TYPE_NOTE    => "Note",
                  );


# define states
my %ISSUE_STATES = ( "open"   => "open",
                     "closed" => "closed",
                   );
my %ISSUE_STATES_HISTORY_ENTRY_MATCH = ($ISSUE_STATES{"open"}   => $HISTORY_TOKEN_REOPENED,
                                        $ISSUE_STATES{"closed"} => $HISTORY_TOKEN_CLOSED,);


# define user file elements
my $USER_FILE_RESERVED_VALUE = 0;    # means to be found in line 0  (this was user issue value but now it's just reserved because issue value is stored within "git config" now!)
my $USER_FILE_MILESTONE      = 1;    # means to be found in line 1


# issue element position
my %ISSUE_ELEMENT_POSITION = ("value"       => 0,
                              "userName"    => 1,
                              "email"       => 2,
                              "type"        => 3,
                              "state"       => 4,
                              "milestone"   => 5,
                              "title"       => 6,
                             );



################################################
############## helper functions ################
################################################
# for a short periode of time it could be necessary to disabled CTRL+C
#$SIG{INT} = \&mySIGINT;
#sub mySIGINT() {
#    printf("CTRL+C not allowed at the moment\n");
#    $SIG{INT} = \&mySIGINT;
#}


# prints error on screen
sub ERROR($) {
    my ($message) = @_;

    # usually error 255 is an error from OS or user input
    #         error 254 is an internal error and needs to fix git-fool
    printf("error: $message\n");
}


# extended exit function
sub EXIT($;$) {
    DEBUG($DEBUG_MED, "EXIT()");
    my ($exitCode, $message) = @_;

    if (defined($message)) {
        if ($exitCode) {
            ERROR($message."\n");
        }
        else {
            printf("$message\n\n");
        }
    }
    exit($exitCode);
}


# print string as hex
sub printHex($) {
    my ($string) = @_;

    for (my $i=0; $i<length($string); $i++) {
        printf("%02X ", ord(substr($string, $i, 1)));
    }
    printf("\n");
}


# compares two arrays
sub arraysEqual($$) {
    my ($array1Ref, $array2Ref) = @_;

    return 0 unless @{$array1Ref} == @{$array2Ref};         # return false if #elements are different!

    my $i = 0;
    foreach my $element (@{$array1Ref}) {
        return 0 unless $element eq ${$array2Ref}[$i++];    # return false if at least one element differs
    }

    return 1;                                               # if arrays are identical return true
}


# own chomp() version
sub CHOMP {
    my ($ref) = @_;
    
    if (ref($ref) eq "ARRAY") {
        for (my $i = 0; $i < scalar(@$ref); $i++) {
            ${$ref}[$i] =~ s/[\x0A\x0D]+$//;
        }
    }
    elsif (ref($ref) eq "SCALAR") {
        ${$ref} =~ s/[\x0A\x0D]+$//;
    }
    else {
        EXIT(254, "internal error - CHOMP() only supports array and scalar refs, nth. else!");
    }
}


# usually used with title where not all characters are possible
sub normalizeString {
    my ($titleRef) = @_;

    CHOMP($titleRef);
    ${$titleRef} =~ s/[\x00-\x1F\x7F]//g;   # replace not allowed characters from string
    ${$titleRef} =~ s/(^(\")+|(\")+$)//g;   # replace quotation mark at beginning and end of the string
    ${$titleRef} =~ s/\//_/g;               # slash (/) is not allowed inside e.g. the title so replace all of them by underscore (_)

}


# debug outputs
sub DEBUG($$) {
    my ($level, $message) = @_;
    if ($DEBUG >= $level) {
        printf("DEBUG[$level] - $message\n");
        my ($package, $filename, $line, $subroutine) = caller(0);
        printf("  from $filename".":$line");
        ($package, $filename, $line, $subroutine) = caller(1);
        if ($package && $filename && $line && $subroutine) {
            if (rindex($subroutine, ':')) {
                $subroutine = substr($subroutine, rindex($subroutine, ':')+1);
            }
            printf(" ($subroutine())\n");
        }
        else {
            printf(" (main())\n");
        }
    }
}


# git interface
sub git {
    my ($command, $expectedLines) = @_;
    
    #printf("git command: $command\n");
    
    # execute git command and chomp new lines
    my @result = `git $command 2>&1`;
    CHOMP(\@result);

    # if expected lines are given check if we have received what we expected
    if ($expectedLines && scalar(@result) != $expectedLines) {
        print Dumper (@result);
        #EXIT(255, "received not what we expected from git (".scalar(@result)." lines)!");
        printf("did not received what we expected from git (".scalar(@result)." lines)!\n");
        return undef;
    }


    if (scalar(@result) == 1)   {       # return the expected line
        return $result[0];
    }
    elsif (scalar(@result) > 1) {       # return all received lines
        return @result;
    }
    else {
        return undef;                   # no return from git so return undef
    }
}


# read user.name from git config
sub prepareUserName($) {
    DEBUG($DEBUG_MED, "prepareUserName()");
    my ($errorHandling) = @_;

    # only if $userName is not yet set because of performance reaseons!
    if (!$userName) {
        $userName = git("config user.name", 1);

        # user.name must be set to make git fool working!
        if (!$userName && $errorHandling) {
            EXIT(255, "user.name not set in git!");
        }
        $shortUserName = uc(substr($userName, 0, 2));

        # if $shortUserName length is less than 2 $userName length is also less than two but two characters are our minimum so enlarge them!!!
        if (length($shortUserName) < 2) {
            $userName      .= "_";
            $shortUserName .= "_";
        }
    }
}


# read user.email from git config
sub prepareEmail($) {
    DEBUG($DEBUG_MED, "prepareEmail()");
    my ($errorHandling) = @_;

    # only if $email is not yet set because of performance reaseons!
    if (!$email) {
        $email = git("config user.email", 1);

        if (!$email && $errorHandling) {
            EXIT(255, "user.email not set in git!");
        }
    }
}


# read core.editor from git config (environments, e.g. GIT_EDITOR will be ignored!)
sub prepareEditor() {
    DEBUG($DEBUG_MED, "prepareEditor()");

    # only if $editor is not yet set because of performance reaseons!
    if (!$editor) {
        $editor = git("config core.editor", 1);
        if (!$editor) {
            $editor = "vi";
        }
    }
}


# read current checkout
sub prepareCheckout($) {
    DEBUG($DEBUG_MED, "prepareCheckout()");
    my ($errorHandling) = @_;

    if (!$checkout) {
        my @checkout = git("rev-parse HEAD");   # usually answer contains only one line but if repository dosen't exist or is a new one we will get some error messages!
        if (scalar(@checkout) != 1) {
            $checkout = "\"not within checkout\"";
        }
        else {
            $checkout = $checkout[0];
        }

        if (!$checkout && $errorHandling) {
            EXIT(255, "git-fool needs a valid checkout!");
        }
    }
}


# build git-fool system file name
sub getFileName($;@);       # prototyping
sub getFileName($;@) {
    DEBUG($DEBUG_MED, "getFileName()");

    my ($fileType, @parameters) = @_;

    if ($fileType == $FILE_NAME_ISSUES) {   # .../.fool/issues
        if (scalar(@parameters) != 0) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }

        my $fileName = $FILE_NAMES{$fileType};
        return ($fileName, $foolPath."/".$fileName);
    }
    elsif ($fileType == $FILE_NAME_TEMP || $fileType == $FILE_NAME_BACKUP) {    # .../.fool/<two characters of user>/<email>.temp | .../.fool/<two characters of user>/<email>.bakup
        if (scalar(@parameters) != 0) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }
        prepareEmail(1);

        my $fileName = $FILE_NAMES{$fileType};
        return ($fileName, $userPath."/".$email.$fileName);
    }
    elsif ($fileType == $FILE_NAME_CERTAIN_ISSUE) { # .../.fool/<counter>_<user>_<email>
        if (scalar(@parameters) != 3) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }
        my ($issueValue, $userName, $email) = @parameters;

        my $fileName = ".".join("_", ($issueValue, $userName, $email));
        return ($fileName, $foolPath."/".$fileName);
    }
    elsif ($fileType == $FILE_NAME_CURRENT_ISSUE) { # .../.fool/<counter>_<user>_<email>
        if (scalar(@parameters) != 1) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }
        my ($issueValue) = @parameters;
        prepareUserName(1);
        prepareEmail(1);

        return getFileName("$FILE_NAME_CERTAIN_ISSUE", $issueValue, $userName, $email);
    }
    elsif ($fileType == $FILE_NAME_USER) {  # .../.fool/<two characters of user>/<email>
        if (scalar(@parameters) != 0) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }

        return ($email, $userPath."/".$email);
    }
    else {
        EXIT(254, "internal error - not handled file type: $fileType");
    }
}

# find main directory that contains ".git" and if initialization is already done also ".fool"
sub findRepoMainDir() {
    DEBUG($DEBUG_MED, "findRepoMainDir()");
    $mainPath = cwd();
    while (!(-d $mainPath."/.git")) {
        $mainPath = substr($mainPath, 0, rindex($mainPath, '/'));
        if (!$mainPath) {
            EXIT(255, "not inside a git repository!");
        }
    }
}


# fill $foolPath and $issuesFile variables
sub setFoolDir() {
    DEBUG($DEBUG_MED, "findFoolDir()");

    # get repo main path if not already set
    if (!$mainPath) {
        findRepoMainDir();
    }

    $foolPath   = $mainPath."/.fool";
    $issuesFile = getFileName($FILE_NAME_ISSUES);
}


# fill $userPath and $userFile variables
sub setUserDir() {
    DEBUG($DEBUG_MED, "findUserDir()");

    prepareEmail(1);
    prepareUserName(1);

    # get fool path if not already set
    if (!$foolPath) {
        setFoolDir();
    }

    $userPath    = $foolPath."/".$shortUserName;
    $userFile    = getFileName($FILE_NAME_USER);
}


# test if .fool directory exists
sub testFoolDir() {
    DEBUG($DEBUG_MED, "testFoolDir()");

    if (!$foolPath) {
        setFoolDir();
    }

    if (!(-d $foolPath) || !(-e $issuesFile)) {
        EXIT(255, "git-fool seems not to be initialized, run 'git-fool init'!");
    }
}


# test if .fool directory exists
sub testUserDir() {
    DEBUG($DEBUG_MED, "testUserDir()");

    if (!$userPath) {
        setUserDir();
    }

    if (!(-d $userPath) || !(-e $userFile)) {
        EXIT(255, "git-fool user path not initialized, run 'git-fool new'!");
    }
}


# prepare .fool directory
sub prepareFoolDir() {
    DEBUG($DEBUG_MED, "prepareFoolDir()");

    # find main directory of current repository and set $foolPath variable
    setFoolDir();

    # create .fool path if not exists
    if (!(-d $foolPath)) {
        mkdir($foolPath) || EXIT(255, "cannot create directory $foolPath: $!");
    }

    # create .fool/issues file if not exists
    if (!(-e getFileName($FILE_NAME_ISSUES))) {
        my ($fileName, $file) = getFileName($FILE_NAME_ISSUES);
        createFile($file);
    }
}


# prepare .fool/<user> directory and .fool/<user>/<email> file
sub prepareUserDir() {
    DEBUG($DEBUG_MED, "prepareUserDir()");

    # find user directory
    setUserDir();

    # create user directory if not exists
    if (!(-d $userPath)) {
        mkpath($userPath) || EXIT(255, "cannot create directory $userPath: $!");;
    }

    # create .fool/<user>/latest if doesn't exist and fill it with 0 otherwise let it untouched
    if (!(-e $userFile)) {
        # usually initial value could be given directly within an array ref, e.g. ["0", "0.1"] but this makes it harder to find this code position if sb. want to change sth.
        my @initialUserFileContent = ();
        $initialUserFileContent[$USER_FILE_RESERVED_VALUE] = "reserved line!";
        $initialUserFileContent[$USER_FILE_MILESTONE]      = "0.1";
        writeFile($userFile, \@initialUserFileContent);
    }
}


# creates a short issue tag from given parameters (issue value and user name)
sub getShortIssueTag($$) {
    DEBUG($DEBUG_MED, "getShortIssueTag()");
    my ($issueValue, $userName) = @_;

    return ($issueValue."/".$userName);
}


# create an issue tag from given parameter and current global value
sub getCurrentShortIssueTag($) {
    DEBUG($DEBUG_MED, "getCurrentShortIssueTag()");
    my ($issueValue) = @_;

    return getShortIssueTag($issueValue, $userName);
}


# creates an issue tag from given parameters (issue value, user name and email address)
sub getIssueTag($$$) {
    DEBUG($DEBUG_MED, "getCurrentShortIssueTag()");
    my ($issueValue, $userName, $email) = @_;

    return (getShortIssueTag($issueValue, $userName)."/".$email);
}


# create an issue tag from given parameter and current global values
sub getCurrentIssueTag($) {
    DEBUG($DEBUG_MED, "getCurrentShortIssueTag()");
    my ($issueValue) = @_;

    return getIssueTag($issueValue, $userName, $email);
}


# create user id from given parameters (user name and email address)
sub getUserId($$) {
    DEBUG($DEBUG_MED, "getUserId()");
    my ($userName, $email) = @_;

    return ($userName."/".$email);
}


# create user id from current user
sub getCurrentUserId() {
    DEBUG($DEBUG_MED, "getCurrentUserId()");
    prepareEmail(1);
    prepareUserName(1);

    return getUserId($userName, $email);
}


# inserts a given string into HISTORY section in a given tag hash
sub addHistory($$;$) {
    DEBUG($DEBUG_MED, "addHistory()");
    my ($token, $tagHashRef, $comment) = @_;

    if (!${$tagHashRef}{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}}) {
        ${$tagHashRef}{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}} = [];
    }

    if (!$HISTORY_TOKENS{$token}) {
        EXIT(254, "history token [$token] doesn't exist!");
    }

    my $entry = $HISTORY_TOKENS{$token}.strftime("UTC, %b %e %H:%M:%S %Y", gmtime())." -by- ".getCurrentUserId()." -at- $checkout";       # @todo: branch/tag should be stored here... git symbolic-ref -q --short HEAD || git describe --tags --exact-match

    if (defined($comment)) {
        $entry .= " - $comment";
    }

    push(@{${$tagHashRef}{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}}}, $entry);
}


# create issue entry
sub createIssueEntry($$$$$) {
    DEBUG($DEBUG_MED, "createIssueEntry()");
    my ($issueTag, $issueType, $issueState, $milestone, $issueTitle) = @_;

    if (!($issueTag =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)$/)) {
        EXIT(254, "git-fool bug: createIssueEntry() got wrong \$issueTag parameter = $issueTag");
    }

    my ($value, $userName, $email) = ($1, $2, $3);


    my @issueLine;
    @issueLine[$ISSUE_ELEMENT_POSITION{"value"}]     = $value;
    @issueLine[$ISSUE_ELEMENT_POSITION{"userName"}]  = $userName;
    @issueLine[$ISSUE_ELEMENT_POSITION{"email"}]     = $email;
    @issueLine[$ISSUE_ELEMENT_POSITION{"type"}]      = $issueType;
    @issueLine[$ISSUE_ELEMENT_POSITION{"state"}]     = $issueState;
    @issueLine[$ISSUE_ELEMENT_POSITION{"milestone"}] = $milestone;
    @issueLine[$ISSUE_ELEMENT_POSITION{"title"}]     = $issueTitle;

    if (scalar(keys(%ISSUE_ELEMENT_POSITION)) != scalar(@issueLine)) {
        EXIT(254, "git-fool bug: \%ISSUE_ELEMENT_POSITION doesn't fit to createIssueEntry(), one of them has been changed!");
    }

    return join("/", @issueLine);
}


# get issue element position
sub issueElementPosition {
    my ($element) = @_;

    if (defined($ISSUE_ELEMENT_POSITION{$element})) {
        return $ISSUE_ELEMENT_POSITION{$element};
    }
    else {
        return -1;
    }
}


# sets issue value for current user in "git config"
sub setIssueValue {
    my ($issueValue) = @_;
    
    git("config fool.$userName.id $issueValue");
}

# returns issue value from current user
sub getIssueValue {
    #my $issueValue = git("config --get fool.$userName.id", 1);     # for debugging
    my $issueValue = git("config --get fool.$userName.id");

    if (!defined($issueValue)) {
        $issueValue = 0;
        setIssueValue($issueValue);
        printf("no issue value found, initialized it with $issueValue!\n\n");
    }
    
    return $issueValue;
}

# reads a string file into an array
sub readFile($) {
    DEBUG($DEBUG_MED, "readFile()");
    my ($fileName) = @_;

    my @fileContent = ();

    if (-e $fileName) {
        my $FH;
        open($FH, "<", $fileName) || EXIT(255, "cannot open $fileName: $!");
        while (<$FH>) {
            CHOMP(\$_);
            push(@fileContent, $_);
        }
        close($FH);
    }
    else {
        ERROR("file $fileName doesn't exist!");     # if file doesn't exist show error message but don't stop processing otherwise whole issue tracking won't work anymore if one file is missing!
    }

    return @fileContent;
}


# writes content of a given array ref into a file
sub writeFile($$) {
    DEBUG($DEBUG_MED, "writeFile()");

    my ($fileName, $linesRef) = @_;

    my $FH;
    open($FH, ">", $fileName) || EXIT(255, "cannot open $fileName: $!");

    foreach my $line (@{$linesRef}) {
        if (defined($line)) {
            print($FH $line."\n");
        }
    }
    close($FH);
}


# adds given lines to an existing file if it doesn't exist it will be created
sub appendFile($$) {
    DEBUG($DEBUG_MED, "appendFile()");
    my ($fileName, $linesRef) = @_;

    my $FH;
    open($FH, ">>", $fileName) || EXIT(255, "cannot open $fileName: $!");

    foreach my $line (@{$linesRef}) {
        print($FH $line."\n");
    }
    close($FH);
}


# creates an empty file, an existing one will be overwritten
sub createFile($) {
    DEBUG($DEBUG_MED, "createFile()");

    my ($fileName) = @_;

    writeFile($fileName, []);
}


# writes a given tag hash to a file (first writes optional leading tagless sections followed by optional tagged sections, tag means [<tag>])
sub writeTaggedFile($$) {
    DEBUG($DEBUG_MED, "writeTaggedFile()");
    my ($fileName, $fileContentRef) = @_;

    # sub function for writing single body sections to prefent code duplication!
    my $subFunction = sub {
        my ($FH, $linesRef) = @_;

        my $lastLine = "";

        # now write all lines from current section
        foreach my $line (@{$linesRef}) {
            print($FH $line."\n");
            $lastLine = $line;
        }

        # ensure to have at least one empty line between sections
        if ($lastLine) {
            print($FH "\n");
        }
    };

    my $FH;
    open($FH, ">", $fileName) || EXIT(255, "cannot open $fileName: $!");

    # print tagless section (only body without any tag) at the beginning
    if (${$fileContentRef}{"none"}) {
        $subFunction->($FH, ${$fileContentRef}{"none"});
        delete(${$fileContentRef}{"none"});
    }

    # now print all other sections
    foreach my $key (sort(keys(%{$fileContentRef}))) {
        # print section tag
        print($FH $key."\n");
        my $lastLine = "";

        # print section body
        $subFunction->($FH, ${$fileContentRef}{$key});
    }

    close($FH);
}


# read whole tagged string file (means file with an optional leading tagless sections followed by optional tagged sections, tag means [<tag>])
sub readTaggedFile($) {
    DEBUG($DEBUG_MED, "readTaggedFile()");
    my ($fileName) = @_;

    my @lines = readFile($fileName);

    my %tagHash = ("none" => []);

    my $currenTag = "none";
    foreach my $line (@lines) {
        CHOMP(\$line);

        # tag line found?
        if ($line =~ /^(\[[^]]+\])$/) {
            $currenTag = $1;
            $tagHash{$currenTag} = [];           # create new tag entry in tag hash
            next;                                   # line handled take next one
        }

        push(@{$tagHash{$currenTag}}, $line);    # if not a tag line push it into current tag content array
    }

    foreach my $section (keys(%tagHash)) {
        while ($tagHash{$section} && scalar(@{$tagHash{$section}}) && !length(${$tagHash{$section}}[-1])) {  # remove latest lines as long as they are empty ones
            pop(@{$tagHash{$section}});
        }
    }

    return %tagHash;
}


# if given string is longer than given size string will be cut and an ellipse will be added
sub shortenString($$) {
    DEBUG($DEBUG_MED, "shortenString()");
    my ($string, $size) = @_;

    if (length($string) > $size) {
        $string = substr($string, 0, $size-3)."...";
    }

    return $string;
}


# print one issue to screen (short, medium or long version)
sub printIssue($$$) {
    DEBUG($DEBUG_MED, "printIssue()");
    my ($line, $printSize, $isFirstLine) = @_;

    my $ISSUE_LENGTH     = 12;      # only used for short, for medium and long it's uncut
    my $TYPE_LENGTH      =  4;      # only used for short and medium, for long it's uncut
    my $STATE_LENGTH     =  6;      # only used for short and medium, for long it's uncut
    my $MILESTONE_LENGTH = 10;      # only used for short and medium, for long it's uncut

    my $BETWEEN_GAPS     =  2;      # spaces between the columns
    my $MEDIUM_PRE_GAP   =  5;      # spaces in front of title in medium case

    my $MEDIUM_TITLE     = 80 - (                $TYPE_LENGTH + $STATE_LENGTH + $MILESTONE_LENGTH + 3*$BETWEEN_GAPS + $MEDIUM_PRE_GAP);     # left for short  title if screen widht = 80
    my $SHORT_TITLE      = 80 - ($ISSUE_LENGTH + $TYPE_LENGTH + $STATE_LENGTH + $MILESTONE_LENGTH + 4*$BETWEEN_GAPS                  );     # left for medium title if screen widht = 80

    my ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();


    # printSize: 0=short, 1=medium, 2=long
    #
    # short:
    # 12345678901234567890123456789012345678901234567890123456789012345678901234567890
    # ISSUE         TITLE                                      TYPE  STATE   MILESTONE
    # --------------------------------------------------------------------------------
    # 3/FOOBARM...  that's a new one                           Bug   open    1.2
    # 3/3DES        that's another one                         Bug   closed  0.1
    # 4/3DES        and this one has such an enormous long...  Task  open    0.3
    # \__________|xx\_______________________________________|xx\__|xx\____|xx\_______|
    #            |                                          |     |       |          |
    #            |                                          |     |       |           ------- milestone length is 9 characters if it is longer it will be truncated
    #            |                                          |     |        ------------------ state length is 6 characters if it is longer it will be truncated
    #            |                                          |      -------------------------- type length is 4 characters if it is longer it will be truncated
    #            |                                           -------------------------------- everything that is left will be used for title if it is longer it will be shortened
    #            |                                                                              if screen is larger than 80 characters title will get the extra size
    #             --------------------------------------------------------------------------- short issue tag (without email) length is 12 characters if it is longer it will be shortened
    #
    #
    # medium:
    # 12345678901234567890123456789012345678901234567890123456789012345678901234567890
    # ISSUE/TITLE                                              TYPE  STATE   MILESTONE
    # --------------------------------------------------------------------------------
    # 3/FOOBARMUCHTOOLONG/gitx@74th.de                                                        issue tag gets its own line and will not be shortend, in no case, if it is longer it will be wrapped in the next line
    #      that's a new one                                    Bug   open    1.2
    # 3/3DES/git@74th.de
    #      that's another one                                  Bug   closed  0.1
    # 4/3DES/git@74th.de
    #      and this one has such an enormous long...           Task  open    0.3
    # xxxxx\________________________________________________|xx\__|xx\____|xx\_______|
    #                                                       |     |       |          |
    #                                                       |     |       |           ------- milestone length is 9 characters if it is longer it will be truncated
    #                                                       |     |        ------------------ state length is 6 characters if it is longer it will be truncated
    #                                                       |      -------------------------- type length is 4 characters if it is longer it will be truncated
    #                                                        -------------------------------- everything that is left will be used for title if it is longer it will be shortened
    #                                                                                           if screen is larger than 80 characters title will get the extra size
    #
    #
    # large:
    # 12345678901234567890123456789012345678901234567890123456789012345678901234567890
    # ISSUE     : 3/FOOBARMUCHTOOLONG/gitx@74th.de                                            all entries are printed unshortened, if they are longer they will be wrapped in the next line
    # TITLE     : that's a new one
    # TYPE      : Bug
    # STATE     : open
    # MILESTONE : 1.2
    #
    # [HISTORY]
    # created: CET, Do Jan  2 19:54:03 2014 at 7411ba78e8e9519a970612929dc914da81f51108

    # issue line has to be printed
    if ($line =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/) {
        # process with line elements
        my ($issueValue, $issueUserName, $issueEmail, $issueType, $issueState, $issueMilestone, $issueTitle) = ($1, $2, $3, $4, $5, $6, $7);
        my $shortIssueTag = getShortIssueTag($issueValue, $issueUserName);
        my $issueTag      = getIssueTag($issueValue, $issueUserName, $issueEmail);

        # print long version
        if ($printSize == 2) {  # 0=short, 1=medium, 2=long
            # if this is not the first line to be printed print a ############### separator line
            if (!$isFirstLine) {
                printf(("#" x $wchar)."\n\n");
            }

            # now print header line
            printf("ISSUE     : %s\n".
                   "TITLE     : %s\n".
                   "TYPE      : %s\n".
                   "STATE     : %s\n".
                   "MILESTONE : %s\n\n", $issueTag, $issueTitle, $issueType, $issueState, $issueMilestone);

            # now try to print the comment&HISTORY file
            my $certainIssueFile   = getFileName($FILE_NAME_CERTAIN_ISSUE, $issueValue, $issueUserName, $issueEmail);
            if ($certainIssueFile && -s $certainIssueFile) {
                my @commentHistoryFile = readFile($certainIssueFile);
                foreach my $line (@commentHistoryFile) {
                    printf("$line\n");
                }
            }
            else {
                EXIT(255, "no comment/history file found: $certainIssueFile");                  # @todo: implement autorepair function!?
            }
            return;
        }

        # print medium version
        if ($printSize == 1) {  # 0=short, 1=medium, 2=long
            ($MEDIUM_TITLE += $wchar - 80) if ($wchar > 80);     # if screen is smaller than 80 characters don't recalulate title length... it will be wrapped then!

            # if first line print the header
            if ($isFirstLine) {
                printf("%-".($MEDIUM_TITLE + $MEDIUM_PRE_GAP + $BETWEEN_GAPS)."s%-".($TYPE_LENGTH + $BETWEEN_GAPS)."s%-".($STATE_LENGTH + $BETWEEN_GAPS)."s%s\n", "ISSUE/TITLE", "TYPE", "STATE", "MILESTONE");
                printf(("-" x $wchar)."\n");
            }

            # now shorten the title to a propper length
            my $issueTitle = shortenString($issueTitle, $MEDIUM_TITLE);

            # at least print the issue (first line = issue tag, second line = rest)
            printf("%s\n", $issueTag);
            printf((" " x $MEDIUM_PRE_GAP)."%-".($MEDIUM_TITLE+$BETWEEN_GAPS)."s%-".($TYPE_LENGTH+$BETWEEN_GAPS)."s%-".($STATE_LENGTH+$BETWEEN_GAPS)."s%s\n\n", $issueTitle, $issueType, $issueState, $issueMilestone);

            return;
        }

        # print short version
        if ($printSize == 0) {  # 0=short, 1=medium, 2=long
            ($SHORT_TITLE += $wchar - 80) if ($wchar > 80);     # if screen is smaller than 80 characters don't recalulate title length... it will be wrapped then!

            # if first line print the header
            if ($isFirstLine) {
                printf("%-".($ISSUE_LENGTH + $BETWEEN_GAPS)."s%-".($SHORT_TITLE + $BETWEEN_GAPS)."s%-".($TYPE_LENGTH + $BETWEEN_GAPS)."s%-".($STATE_LENGTH + $BETWEEN_GAPS)."s%s\n", "ISSUE", "TITLE", "TYPE", "STATE", "MILESTONE");
                printf(("-" x $wchar)."\n");
            }

            # now shorten some variables to a propper length
            my $issueTitle    = shortenString($issueTitle,    $SHORT_TITLE);
            my $shortIssueTag = shortenString($shortIssueTag, $ISSUE_LENGTH);

            # at least print the issue (first line = issue tag, second line = rest)
            printf("%-".($ISSUE_LENGTH + $BETWEEN_GAPS)."s%-".($SHORT_TITLE + $BETWEEN_GAPS)."s%-".($TYPE_LENGTH + $BETWEEN_GAPS)."s%-".($STATE_LENGTH + $BETWEEN_GAPS)."s%s\n", $shortIssueTag, $issueTitle, $issueType, $issueState, $issueMilestone);

            return;
        }
    }
    else {
        EXIT(255, "found damaged line in issue file: [$line]");                                 # @todo: implement autorepair function!?
    }
}


# prints issues from issues list and uses an index list to select those items to be printed
sub printIndexedIssueList {
    DEBUG($DEBUG_MED, "printIndexedIssueList()");
    my ($issuesFileContentRef, $foundListRef, $printSize) = @_;

    my $isFirstLine = 1;
    foreach my $index (@{$foundListRef}) {
        my $line = ${$issuesFileContentRef}[$index];
        if (defined($line)) {   # with this we can use "delete($array[$index])" what will be nice sth.
            printIssue($line, $printSize, $isFirstLine);
        }
        $isFirstLine = 0;
    }
}


# returns an array with indices (if pattern list is empty a match with all lines will be faked)
sub matchPatterns {
    DEBUG($DEBUG_MED, "matchPatterns()");
    my ($listRef, $patternListRef, $patternNegativListRef) = @_;

    my @foundIndices = ();

    # compress arrays to remove "undefined" elemenst makes the live easier for our callers!
    if (defined($patternListRef)) {
        @{$patternListRef} = grep(defined, @{$patternListRef});
    }
    else {
        $patternListRef = [];
    }
    if (defined($patternNegativListRef)) {
        @{$patternNegativListRef} = grep(defined, @{$patternNegativListRef});
    }
    else {
        $patternNegativListRef = [];
    }


    # now handle all issues' lines
    for (my $index = 0; $index < scalar(@{$listRef}); $index++) {   # all elements
        my $patternFound = 1;
        foreach my $pattern (@{$patternListRef}) {                  # try to match all given patterns if one doesn't match ignore current element
            if ((${$listRef}[$index] !~ /$pattern/)) {
                $patternFound = 0;
                last;
            }
        }
        next unless ($patternFound);    # if no pattern matched continue with next line...

        # if an optional negative pattern list has been given...
        if (defined($patternNegativListRef)) {
            foreach my $pattern (@{$patternNegativListRef}) {                  # try to match all given negative patterns if one match ignore current element
                if ((${$listRef}[$index] =~ /$pattern/)) {
                    $patternFound = 0;
                    last;
                }
            }
            next unless ($patternFound);    # if no pattern matched continue with next line...
        }

        push(@foundIndices, $index);
    }

    return [@foundIndices];
}


# handle command line, getopt cannot be used in our case because we don't want to give -- all the time to prevent patterns be matched as parameters!
sub handleCommandLine {
    my ($patternsRef, $paramsRef) = @_;

    for (my $i = 0; $i < scalar(@{$paramsRef}); $i++) {
        my $matched = 0;
        foreach my $key (keys(%{$patternsRef})) {
            if (${$paramsRef}[$i] =~ /^($key)$/) {
                if (!length(${$patternsRef}{$key})) {
                    ${$patternsRef}{$key} = $1;
                    #printf("match ${$patternsRef}{$key}, fill with $1\n");
                    shift(@{$paramsRef});
                    $i--;   # correction because we removed one element from the paramsRef array
                    #printf(Dumper $paramsRef);
                    #printf("\n\n");
                    $matched = 1;
                }
                last;   # finish here in either case... because if we find a parameter a second time it must already be an "arguments pattern"
            }
        }
        last if (!$matched);    #to prevent "arguments pattern" to be matched as command line switches (e.g. -a, -m, ...) stop matching when first argument doesn't match any possible command line switch
    }
}


# git-fool wide uniform input method
my $terminal = Term::ReadLine->new();
$terminal->ornaments(0);
sub inputLine {
    my ($prompt) = @_;

    return $terminal->readline($prompt);
}


################################################
############## fool commands ###################
################################################


# initialize git repository for git-fool (.fool folder will be created)
sub initCmd {
    DEBUG($DEBUG_LOW, "initCmd()");

    # prepare fool dir if necessary
    prepareFoolDir();
    
    printf("initialized new tracker in $foolPath\n");
}


# create new issue
sub newCmd {  # new [-c|-p] <title>
    DEBUG($DEBUG_LOW, "newCmd()");
    my @arguments = @_;

    # check command arguments
    if (scalar(@arguments) < 1 || (scalar(@arguments) == 1 && ($arguments[0] eq "-c" || $arguments[0] eq "-p"))) {
        $cmd{"help"}->("new", "'git-fool new' parameters mismatch", 255);
    }

    testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)
    prepareUserDir();   # may be we have to create the user directory if this is the first time current user calls 'new' command

    # reading milestone from user file
    my @userFileContent   = readFile($userFile);
    
    # get last issue value from "git config"
    my $currentIssueValue = getIssueValue();

    $currentIssueValue++;  # increment for current issue

    # checking milestone read from file
    if (!length($userFileContent[$USER_FILE_MILESTONE])) {
        EXIT(255, "$userFile contains invalid milestone value!");                               # @todo: implement autorepair function!?
    }

    my $tempFile  = "";
    my $issueType = $ISSUE_TYPE_DEFAULT;

    if ($arguments[0] eq "-c" || $arguments[0] eq "-p") {
        # reading milestrom from user input
        my $newMilestone = inputLine("Milestone [$userFileContent[$USER_FILE_MILESTONE]]: ");     # pressing just [ENTER] doesn't change default milestone
        normalizeString(\$newMilestone);     # make a clean string out of it
        if ($newMilestone) {
            $userFileContent[$USER_FILE_MILESTONE] = $newMilestone;
        }

        # reading issue type from user input
        while(1) {
            my $prompt = "issue type: ";
            my $counter = 1;
            foreach my $issue (sort(keys(%ISSUE_TYPES))) {
                $prompt .= "$issue-$ISSUE_TYPES{$issue}";
                if ($counter++ < scalar(keys(%ISSUE_TYPES))) {
                    $prompt .= ", ";
                }
                else {
                    $prompt .= " [$issueType]: ";  # print default option if user presses just [ENTER]
                }
            }

            my $newIssueType = inputLine($prompt);
            CHOMP(\$newIssueType);
            if ($newIssueType =~ /^\d+$/ && $newIssueType >= 0 && $newIssueType < scalar(keys(%ISSUE_TYPES))) {      # valid user input
                $issueType = $newIssueType;
                last;
            }
            elsif (!$newIssueType) {    # just [ENTER]
                last;
            }
            else {  # invalid user input
                printf("issue type $newIssueType is not valid!\n");
            }
        }

        # prepare and run default editor if parameter -c has been given
        if ($arguments[0] eq "-c") {
            prepareEditor();
            $tempFile = getFileName($FILE_NAME_TEMP);
            createFile($tempFile);              # ensure that .fool/<user>/.temp exists and is empty!
            system("$editor $tempFile");        # open editor to edit temp file
        }

        shift(@arguments);      # remove cmd from arguments list because rest is the issue title
    }
    my $issueTypeText = $ISSUE_TYPES{$issueType};

    my $title = join(" ", @arguments);  # create title out of the rest of given arguments
    normalizeString(\$title);

    if (!(length($title))) {    # after normalization it's possible that given title is empty, e.g. if sth. like '""""""' was given
        EXIT(255, "title cannot be empty!");
    }


    # prepare necessary user strings
    prepareEmail(1);
    prepareUserName(1);
    prepareCheckout(1);

    # if exists read comment file to be handled when comment/HISTORY file is written
    my %tagHash = ();
    if ($tempFile && -s $tempFile) {
        %tagHash = readTaggedFile($tempFile);
    }

    # create comment/history file
    if (!$tagHash{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}}) {
        $tagHash{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}} = [];
    }

    # now write current issue file (with comments and HISTORY)
    addHistory($HISTORY_TOKEN_CREATED, \%tagHash);
    my ($currentIssueFileName, $currentIssueFile) = getFileName($FILE_NAME_CURRENT_ISSUE, $currentIssueValue);
    writeTaggedFile($currentIssueFile, \%tagHash);

    # comment file content has been written into history file so we can delete it now
    if ($tempFile && -s $tempFile) {
        unlink($tempFile);
    }

    # user info
    printf("created issue ".$currentIssueFileName);

    # store new issue value
    setIssueValue($currentIssueValue);

    # write issue into issues file
    appendFile($issuesFile, [createIssueEntry(getCurrentIssueTag($currentIssueValue), $issueTypeText, $ISSUE_STATES{"open"}, $userFileContent[$USER_FILE_MILESTONE], $title)]);
}


# search for certain issues
sub grepCmd {   # grep [-a] [-m|-l] [<pattern(s)>]
    DEBUG($DEBUG_LOW, "grepCmd()");
    my @arguments = @_;

    my $negativePattern = undef;
    my $printSize       = 0;   # 0 -> short, 1 -> medium, 2 -> long

    # check command arguments
    my %commandLineSwitches = ("-a"      => "",
                               "(-m|-l)" => "");

    handleCommandLine(\%commandLineSwitches, \@arguments);
    if (!($commandLineSwitches{"-a"})) {
        $negativePattern = "^".(".+/" x issueElementPosition("state")).$ISSUE_STATES{"closed"}."/.+\$";
    }

    if ($commandLineSwitches{"(-m|-l)"}) {
        if ($commandLineSwitches{"(-m|-l)"} eq "-m") {
            $printSize = 1;
        }
        elsif ($commandLineSwitches{"(-m|-l)"} eq "-l") {
            $printSize = 2;
        }
    }


####################################
    testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)

    # read issues file
    my @issuesFileContent = readFile($issuesFile);
    if (!@issuesFileContent) {
        printf("issue file is empty!\n");
        return;
    }

    # find candidates
    my $foundListRef;
    $foundListRef = matchPatterns(\@issuesFileContent, \@arguments, [$negativePattern]);
    

    # grep candidates (each issue found here is a possible candidate for scanning its comment file)
    my $grepListRef;
    $grepListRef = matchPatterns(\@issuesFileContent, undef, [$negativePattern]);


    # remove all already matched files
    my %temp;
    @temp{@{$foundListRef}} = ();                                   # create a temporary hash out of one of the two arrays
    @{$grepListRef} = grep { ! exists $temp{$_} } @{$grepListRef};  # now let grep to the rest... removing all elements from @{$grepListRef} that are also in @{$foundListRef}


    # now handle all comment files
    my $matchPattern = "^".(".+/" x issueElementPosition("value"))."([^/]+)/([^/]+)/([^/]+)/";
    foreach my $issue (@{$grepListRef}) {
        # try to get value, userName and email from issues line
        if ($issuesFileContent[$issue] =~ $matchPattern) {
            my ($id, $userName, $email) = ($1, $2, $3);
            my ($certainIssueFileName, $certainIssueFile) = getFileName($FILE_NAME_CERTAIN_ISSUE, $id, $userName, $email);

            # read and grep through issue comment file
            my @issuesFileContent = readFile($certainIssueFile);    # it's a tagged file but that doesn't matter, we open it for beeing grepped, not for beeing handled!

            my @tempArguments = @arguments;
            # search manually and don't use grep for this job because grep would search through all lines whereas we can stop with the first that 
            LINE_LOOP:
            foreach my $line (@issuesFileContent) {
                for (my $i = scalar(@tempArguments)-1; $i >=0 ; $i--) {    # count downwards because we removing all matched elements and so we don't have to correct the loop variable if an element has been deleted
                    if ($line =~ $tempArguments[$i]) {
                        splice(@tempArguments, $i, 1);
                    }
                }
                # temporary arguments array is empty means all patterns found!
                if (!scalar(@tempArguments)) {
                    push(@{$foundListRef}, $issue);
                    last;   # last LINE_LOOP
                }
            }
        }
    }


    # finaly sort list because additional elements have been "pushed"
    @{$foundListRef} = sort{$a <=> $b}(@{$foundListRef});

####################################


    # now print them
    printIndexedIssueList(\@issuesFileContent, $foundListRef, $printSize);
}


# list issue(s)
sub lsCmd { # ls [-a] [-m|-l] [<tag> [<pattern(s)>]]
    DEBUG($DEBUG_LOW, "lsCmd()");
    my @arguments = @_;

    my $negativePattern = undef;
    my $printSize       = 0;   # 0 -> short, 1 -> medium, 2 -> long

    # check command arguments
    my %commandLineSwitches = ("-a"      => "",
                               "(-m|-l)" => "");

    handleCommandLine(\%commandLineSwitches, \@arguments);
    if (!($commandLineSwitches{"-a"})) {
        $negativePattern = "^".(".+/" x issueElementPosition("state")).$ISSUE_STATES{"closed"}."/.+\$";
    }

    if ($commandLineSwitches{"(-m|-l)"}) {
        if ($commandLineSwitches{"(-m|-l)"} eq "-m") {
            $printSize = 1;
        }
        elsif ($commandLineSwitches{"(-m|-l)"} eq "-l") {
            $printSize = 2;
        }
    }


    # prepare arguments
    if (scalar(@arguments)) {
        $arguments[0] = "^".$arguments[0];
    }


####################################
    testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)

    # read issues file
    my @issuesFileContent = readFile($issuesFile);
    if (!@issuesFileContent) {
        printf("issue file is empty!\n");
        return;
    }

    # find candidates
    my $foundListRef;
    $foundListRef = matchPatterns(\@issuesFileContent, \@arguments, [$negativePattern]);
    

####################################

    # now print them
    printIndexedIssueList(\@issuesFileContent, $foundListRef, $printSize);
}


# edit existing issue
sub editCmd { # edit [-c|-p] <tag> [<patterns>]
    DEBUG($DEBUG_LOW, "editCmd()");
    my @arguments = @_;
    my $editParts = 0x01 | 0x02;  # 0x00 = not used, 0x01 = parameters only (title, milestone, type), 0x02 = comment only, 0x03 = parameters and comment

    # check command arguments
    if (scalar(@arguments) < 1 || (scalar(@arguments) == 1 && ($arguments[0] eq "-c" || $arguments[0] eq "-p"))) {
        $cmd{"help"}->("edit", "'git-fool edit' parameters mismatch", 255);
    }
    if ($arguments[0] eq "-c") {
        $editParts = 0x02;
        shift(@arguments);
    }
    elsif ($arguments[0] eq "-p") {
        $editParts = 0x01;
        shift(@arguments);
    }


####################################
    testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)

    # read issues file
    my @issuesFileContent = readFile($issuesFile);
    if (!@issuesFileContent) {
        printf("issue file is empty!\n");
        return;
    }

    # find candidates
    my $foundListRef = matchPatterns(\@issuesFileContent, \@arguments);
####################################

    # check if issue found
    if (scalar(@{$foundListRef}) == 0) {
        EXIT(255, "given issue not found");
    }
    elsif(scalar(@{$foundListRef}) > 1) {
        ERROR("more than one issue matches, please restrict search\n");
        printIndexedIssueList(\@issuesFileContent, $foundListRef, 0);
        EXIT(255);
    }

    # now take the only candidate
    my $lineIndex = ${$foundListRef}[0];

    # prepare user directory if necessary because we need it for the temp file
    prepareUserDir();

    # prepare necessary strings (for HISTORY because for the issue we take all information from the issue itself otherwise a user cannot change an issue from another sb. else!)
    prepareEmail(1);
    prepareUserName(1);
    prepareCheckout(1);

    # print issue to screen
    printf("edit...\n");
    printIssue($issuesFileContent[$lineIndex], 0, 1);
    printf("\n");

    # set to 1 if anything of the issue has been changed!
    my $issueChanged = 0;

    # now scan and handle line
    my $line = $issuesFileContent[$lineIndex];
    if ($line =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/) {
        # process with line elements
        my ($issueValue, $issueUserName, $issueEmail, $issueType, $issueState, $issueMilestone, $issueTitle) = ($1, $2, $3, $4, $5, $6, $7);

        if ($issueState eq $ISSUE_STATES{"closed"}) {
            EXIT(255, "issue is closed, reopen it for editing");
        }

        if ($editParts & 0x01) {
            # reading new title from user input
            my $newTitle = inputLine("Title [$issueTitle]: ");    # pressing just [ENTER] doesn't change original title
            normalizeString(\$newTitle);
            if (length($newTitle)) {
                $issueTitle = $newTitle;
                $issueChanged = 1;
            }
    
            # reading milestone from user input
            my $newMilestone = inputLine("Milestone [$issueMilestone]: ");     # pressing just [ENTER] doesn't change default milestone
            CHOMP(\$newMilestone);
            normalizeString(\$newMilestone);
            if ($newMilestone) {
                $issueMilestone = $newMilestone;
                $issueChanged = 1;
            }
    
            # find issue type string and convert it into issue type value
            while (my($key, $value) = each %ISSUE_TYPES) {
                if ($value eq $issueType) {
                    $issueType = $key;
                    last;
                }
            }
    
            # reading issue type from user input
            while(1) {
                my $prompt = "issue type: ";
                my $counter = 1;
                foreach my $issue (sort(keys(%ISSUE_TYPES))) {
                    $prompt .= "$issue-$ISSUE_TYPES{$issue}";
                    if ($counter++ < scalar(keys(%ISSUE_TYPES))) {
                        $prompt .= ", ";
                    }
                    else {
                        $prompt .= " [$issueType]: ";  # print default option if user presses just [ENTER]
                    }
                }
    
                my $newIssueType = inputLine($prompt);
                CHOMP(\$newIssueType);
                if ($newIssueType =~ /^\d+$/ && $newIssueType >= 0 && $newIssueType < scalar(keys(%ISSUE_TYPES))) {      # valid user input
                    $issueType = $newIssueType;
                    $issueChanged = 1;
                    last;
                }
                elsif (!$newIssueType) {    # just [ENTER]
                    last;
                }
                else {  # invalid user input
                    printf("issue type $newIssueType is not valid!\n");
                }
            }
    
            # update issues array and write back issues file if necessary
            if ($issueChanged) {
                $issuesFileContent[$lineIndex] = createIssueEntry(getIssueTag($issueValue, $issueUserName, $issueEmail), $ISSUE_TYPES{$issueType}, $issueState, $issueMilestone, $issueTitle);
                writeFile($issuesFile, \@issuesFileContent);
            }
        }

        if ($editParts & 0x02) {
            # read tagged file
            my ($certainIssueFileName, $certainIssueFile) = getFileName($FILE_NAME_CERTAIN_ISSUE, $issueValue, $issueUserName, $issueEmail);
            my %tagHash = ();
            if ($certainIssueFile && -s $certainIssueFile) {
                %tagHash = readTaggedFile($certainIssueFile);
            }
            else {
                EXIT(255, "changed but no comment/history file found: $certainIssueFile");          # @todo: implement autorepair function!?
            }
    
            # write temp file for beeing edited
            my ($tempFileName, $tempFile) = getFileName($FILE_NAME_TEMP);
            writeFile($tempFile, $tagHash{"none"});
    
            prepareEditor();
            system("$editor $tempFile");        # open editor to edit temp file
    
            my @newComments = readFile($tempFile);
    
            # if anything has been changed recreate comment/history file
            if (!arraysEqual($tagHash{"none"}, \@newComments) || $issueChanged) {
                $tagHash{"none"} = \@newComments;
                addHistory($HISTORY_TOKEN_CHANGED, \%tagHash);
                writeTaggedFile($certainIssueFile, \%tagHash);
            }
            unlink($tempFile);
        }
    }
    else {
        EXIT(255, "found damaged line in issue file: [$line]");                                 # @todo: implement autorepair function!?
    }
}


# copy existing issue
sub cpCmd {   # cp [-n] <tag> [<patterns>]
    DEBUG($DEBUG_LOW, "cpCmd()");
    my @arguments = @_;
    my $autoEdit = 1;

    # check command arguments
    if (scalar(@arguments) < 1 || (scalar(@arguments) == 1 && $arguments[0] eq "-n")) {
        $cmd{"help"}->("cp", "'git-fool cp' parameters mismatch", 255);
    }

    # with -n auto-edit can be disabled
    if ($arguments[0] eq "-n") {
        $autoEdit = 0;
        shift(@arguments);
    }

    # prepare arguments
    $arguments[0] = "^".$arguments[0];

####################################
    testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)

    # read issues file
    my @issuesFileContent = readFile($issuesFile);
    if (!@issuesFileContent) {
        printf("issue file is empty!\n");
        return;
    }

    # find candidates
    my $foundListRef = matchPatterns(\@issuesFileContent, \@arguments);
####################################

    # if only one element found print it always long
    if (scalar(@{$foundListRef}) == 0) {
        EXIT(255, "given issue not found");
    }
    elsif(scalar(@{$foundListRef}) > 1) {
        ERROR("more than one issue matches, please restrict search\n");
        printIndexedIssueList(\@issuesFileContent, $foundListRef, 0);
        EXIT(255);
    }

    # now take the only candidate
    my $lineIndex = ${$foundListRef}[0];

    printf("copy...\n");
    printIssue($issuesFileContent[$lineIndex], 0, 1);
    printf("\n");

    # prepare user directory if necessary because we need it for the issue's user id
    prepareUserDir();

    # reading milestone from user file
    my @userFileContent   = readFile($userFile);

    # get last issue value from "git config"
    my $currentIssueValue = getIssueValue();

    $currentIssueValue++;  # increment for current issue

    # checking milestone read from file
    if (!length($userFileContent[$USER_FILE_MILESTONE])) {
        EXIT(255, "$userFile contains invalid milestone value!");                               # @todo: implement autorepair function!?
    }

    # prepare necessary strings (for HISTORY because for the issue we take all information from the issue itself otherwise a user cannot change an issue from another sb. else!)
    prepareEmail(1);
    prepareUserName(1);
    prepareCheckout(1);

    # now scan and handle line
    my $line = $issuesFileContent[$lineIndex];
    if ($line =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/) {
        # process with line elements
        my ($issueValue, $issueUserName, $issueEmail, $issueType, $issueState, $issueMilestone, $issueTitle) = ($1, $2, $3, $4, $5, $6, $7);

        # store new issue value
        setIssueValue($currentIssueValue);

        # write issue into issues file (id, user name, email will be set to current user, state will be set to open and current default milestone will be used!)
        my $newIssue = createIssueEntry(getIssueTag($currentIssueValue, $userName, $email), $issueType, $ISSUE_STATES{"open"}, $userFileContent[$USER_FILE_MILESTONE], $issueTitle);
        appendFile($issuesFile, [$newIssue]);

        printf("to... ".(getShortIssueTag($currentIssueValue, $userName))."\n\n");

        # read history file from original issue
        my ($certainIssueFileName, $certainIssueFile) = getFileName($FILE_NAME_CERTAIN_ISSUE, $issueValue, $issueUserName, $issueEmail);
        my %tagHash = ();
        if ($certainIssueFile && -s $certainIssueFile) {
            %tagHash = readTaggedFile($certainIssueFile);
        }
        else {
            EXIT(255, "copied but no comment/history file found: $certainIssueFile");           # @todo: implement autorepair function!?
        }

        # replace original [HISTORY] section
        $tagHash{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}} = [];
        addHistory($HISTORY_TOKEN_COPIED, \%tagHash, "from ".getIssueTag($issueValue, $issueUserName, $issueEmail));

        # write history file of new issue
        my ($currentIssueFileName, $currentIssueFile) = getFileName($FILE_NAME_CURRENT_ISSUE, $currentIssueValue);
        writeTaggedFile($currentIssueFile, \%tagHash);

        if ($autoEdit) {
            editCmd("-c", getIssueTag($currentIssueValue, $userName, $email));  # edit comment only
        }
    }
    else {
        EXIT(255, "found damaged line in issue file: [$line]");                                 # @todo: implement autorepair function!?
    }
}


# move existing issue
sub mvCmd {   # mv [-n] <tag> [<patterns>]
    DEBUG($DEBUG_LOW, "cpCmd()");
    my @arguments = @_;
    my $autoEdit = 1;

    # check command arguments
    if (scalar(@arguments) < 1 || (scalar(@arguments) == 1 && $arguments[0] eq "-n")) {
        $cmd{"help"}->("mv", "'git-fool mv' parameters mismatch", 255);
    }

    # with -n auto-edit can be disabled
    if ($arguments[0] eq "-n") {
        $autoEdit = 0;
        shift(@arguments);
    }

    # prepare arguments
    $arguments[0] = "^".$arguments[0];

####################################
    testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)

    # read issues file
    my @issuesFileContent = readFile($issuesFile);
    if (!@issuesFileContent) {
        printf("issue file is empty!\n");
        return;
    }

    # find candidates
    my $foundListRef = matchPatterns(\@issuesFileContent, \@arguments);
####################################

    # if only one element found print it always long
    if (scalar(@{$foundListRef}) == 0) {
        EXIT(255, "given issue not found");
    }
    elsif(scalar(@{$foundListRef}) > 1) {
        ERROR("more than one issue matches, please restrict search\n");
        printIndexedIssueList(\@issuesFileContent, $foundListRef, 0);
        EXIT(255);
    }

    # now take the only candidate
    my $lineIndex = ${$foundListRef}[0];

    printf("copy...\n");
    printIssue($issuesFileContent[$lineIndex], 0, 1);
    printf("\n");

    # prepare user directory if necessary because we need it for the issue's user id
    prepareUserDir();

    # reading milestone from user file
    my @userFileContent = readFile($userFile);
    
    # get last issue value from "git config"
    my $currentIssueValue = getIssueValue();

    $currentIssueValue++;  # increment for current issue

    # checking milestone read from file
    if (!length($userFileContent[$USER_FILE_MILESTONE])) {
        EXIT(255, "$userFile contains invalid milestone value!");                               # @todo: implement autorepair function!?
    }

    # prepare necessary strings (for HISTORY because for the issue we take all information from the issue itself otherwise a user cannot change an issue from another sb. else!)
    prepareEmail(1);
    prepareUserName(1);
    prepareCheckout(1);

    # now scan and handle line
    my $line = $issuesFileContent[$lineIndex];
    if ($line =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/) {
        # process with line elements
        my ($issueValue, $issueUserName, $issueEmail, $issueType, $issueState, $issueMilestone, $issueTitle) = ($1, $2, $3, $4, $5, $6, $7);

        # check if issue is in open state
        if ($issueState eq $ISSUE_STATES{"closed"}) {
            EXIT(255, "issue already closed, used cp command instead");
        }

        # if auto edit is not disabled edit original issue now before it gets closed
        if ($autoEdit) {
            editCmd("-c", getIssueTag($issueValue, $issueUserName, $issueEmail));  # edit comment only
        }

        # set issue into closed state and write issues file back
        $issuesFileContent[$lineIndex] = createIssueEntry(getIssueTag($issueValue, $issueUserName, $issueEmail), $issueType, $ISSUE_STATES{"closed"}, $issueMilestone, $issueTitle);
        writeFile($issuesFile, \@issuesFileContent);

        # store new issue value
        setIssueValue($currentIssueValue);

        # write new issue into issues file (id, user name, email will be set to current user, state will be set to open and current default milestone will be used!)
        my $newIssue = createIssueEntry(getIssueTag($currentIssueValue, $userName, $email), $issueType, $ISSUE_STATES{"open"}, $userFileContent[$USER_FILE_MILESTONE], $issueTitle);
        appendFile($issuesFile, [$newIssue]);

        printf("to... ".(getShortIssueTag($currentIssueValue, $userName))."\n\n");

        # read history file from original issue
        my ($certainIssueFileName, $certainIssueFile) = getFileName($FILE_NAME_CERTAIN_ISSUE, $issueValue, $issueUserName, $issueEmail);
        my %tagHash = ();
        if ($certainIssueFile && -s $certainIssueFile) {
            %tagHash = readTaggedFile($certainIssueFile);
        }
        else {
            EXIT(255, "copied but no comment/history file found: $certainIssueFile");           # @todo: implement autorepair function!?
        }
        addHistory($HISTORY_TOKEN_MOVEDTO, \%tagHash, "to ".getIssueTag($currentIssueValue, $userName, $email));
        addHistory($HISTORY_TOKEN_CLOSED,  \%tagHash, "original state was \"$issueState\"");
        writeTaggedFile($certainIssueFile, \%tagHash);

        # replace original [HISTORY] section
        $tagHash{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}} = [];
        addHistory($HISTORY_TOKEN_MOVEDFROM, \%tagHash, "from ".getIssueTag($issueValue, $issueUserName, $issueEmail));

        # write history file of new issue
        my ($currentIssueFileName, $currentIssueFile) = getFileName($FILE_NAME_CURRENT_ISSUE, $currentIssueValue);
        writeTaggedFile($currentIssueFile, \%tagHash);

        if ($autoEdit) {
            editCmd("-c", getIssueTag($currentIssueValue, $userName, $email));  # edit comment only
        }
    }
    else {
        EXIT(255, "found damaged line in issue file: [$line]");                                 # @todo: implement autorepair function!?
    }
}


# change issue state to "state"
sub stateCmd {    # state [-n] <state> <patterns>
    DEBUG($DEBUG_LOW, "stateCmd()");
    my @arguments = @_;
    my $autoEdit = 1;

    # check command arguments
    if (scalar(@arguments) < 2 || ($arguments[0] ne "-n" && !defined($ISSUE_STATES{$arguments[0]})) || ($arguments[0] eq "-n" && !defined($ISSUE_STATES{$arguments[1]}))) {
        $cmd{"help"}->("state", "'git-fool state' parameters mismatch", 255);
    }
    if ($arguments[0] eq "-n") {
        $autoEdit = 0;
        shift(@arguments);
    }
    my $newState = shift(@arguments);

    # prepare arguments
    $arguments[0] = "^".$arguments[0];

####################################
    testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)

    # read issues file
    my @issuesFileContent = readFile($issuesFile);
    if (!@issuesFileContent) {
        printf("issue file is empty!\n");
        return;
    }

    # find candidates
    my $foundListRef = matchPatterns(\@issuesFileContent, \@arguments);
####################################

    # if only one element found print it always long
    if (scalar(@{$foundListRef}) == 0) {
        EXIT(255, "given issue not found");
    }
    elsif(scalar(@{$foundListRef}) > 1) {
        ERROR("more than one issue matches, please restrict search\n");
        printIndexedIssueList(\@issuesFileContent, $foundListRef, 0);
        EXIT(255);
    }

    # now take the only candidate
    my $lineIndex = ${$foundListRef}[0];

    # prepare user directory if necessary because we need it for the temp file
    prepareUserDir();

    # prepare necessary strings (for HISTORY because for the issue we take all information from the issue itself otherwise a user cannot change an issue from another sb. else!)
    prepareEmail(1);
    prepareUserName(1);
    prepareCheckout(1);

    # set to 1 if anything of the issue has been changed!
    my $issueChanged = 0;

    # now scan and handle line
    my $line = $issuesFileContent[$lineIndex];
    if ($line =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/) {
        # process with line elements
        my ($issueValue, $issueUserName, $issueEmail, $issueType, $issueState, $issueMilestone, $issueTitle) = ($1, $2, $3, $4, $5, $6, $7);

        # check if issue is in open state
        if ($issueState eq $ISSUE_STATES{$newState}) {
            EXIT(255, "issue already in state $newState");
        }

        # if we close an issue we must edit it before, if not we will edit it after state change because if it is already closed we have to open it first!
        if ($ISSUE_STATES{$newState} eq $ISSUE_STATES{"closed"} && $autoEdit) {
            editCmd("-c", getIssueTag($issueValue, $issueUserName, $issueEmail));  # edit comment only
        }

        # set issue into new state
        $issuesFileContent[$lineIndex] = createIssueEntry(getIssueTag($issueValue, $issueUserName, $issueEmail), $issueType, $ISSUE_STATES{$newState}, $issueMilestone, $issueTitle);
        writeFile($issuesFile, \@issuesFileContent);

        printf("change state from $issueState to $ISSUE_STATES{$newState}...\n");
        printIssue($issuesFileContent[$lineIndex], 0, 1);
        printf("\n");

        # read tagged file
        my ($certainIssueFileName, $certainIssueFile) = getFileName($FILE_NAME_CERTAIN_ISSUE, $issueValue, $issueUserName, $issueEmail);
        my %tagHash = ();
        if ($certainIssueFile && -s $certainIssueFile) {
            %tagHash = readTaggedFile($certainIssueFile);
        }
        else {
            EXIT(255, "closed but no comment/history file found: $certainIssueFile");           # @todo: implement autorepair function!?
        }

        # write changed history file back
        my $historyTag;

        if ($ISSUE_STATES_HISTORY_ENTRY_MATCH{$newState}) {
            addHistory($ISSUE_STATES_HISTORY_ENTRY_MATCH{$newState}, \%tagHash, "original state was \"$issueState\"");
        }
        else {
            addHistory($HISTORY_TOKEN_UNKNOWN, \%tagHash, "original state was \"$issueState\"");
            # @todo: error handling here because there is no token for the new state?
        }
        writeTaggedFile($certainIssueFile, \%tagHash);
        if (!$ISSUE_STATES_HISTORY_ENTRY_MATCH{$newState}) {
            EXIT(254, "bug in git-fool, expand \%ISSUE_STATES_HISTORY_ENTRY_MATCH!");
        }

        # if new state is not "closed" we edit it here because it could be closed in have been reopened...
        if ($ISSUE_STATES{$newState} ne $ISSUE_STATES{"closed"} && $autoEdit) {
            editCmd("-c", getIssueTag($issueValue, $issueUserName, $issueEmail));  # edit comment only
        }
    }
    else {
        EXIT(255, "found damaged line in issue file: [$line]");                                 # @todo: implement autorepair function!?
    }
}


# close an open issue
sub closeCmd {    # close [-n] <tag> [<patterns>]
    DEBUG($DEBUG_LOW, "closeCmd()");
    my @arguments = @_;

    # check command arguments
    if (scalar(@arguments) < 1 || (scalar(@arguments) == 1 && $arguments[0] eq "-n")) {
        $cmd{"help"}->("close", "'git-fool close' parameters mismatch", 255);
    }

    # prepare arguments
    my @headArguments = ();
    if ($arguments[0] eq "-n") {
        $arguments[1] = "^".$arguments[1];
        push(@headArguments, shift(@arguments));
    }
    else {
        $arguments[0] = "^".$arguments[0];
    }
    push(@headArguments, $ISSUE_STATES{"closed"});

    # now call stateCmd() it will do the rest
    $cmd{"state"}->(@headArguments, @arguments);
}

# reopen an already closed issue again
sub reopenCmd {   # reopen [-n] <tag> [<patterns>]
    DEBUG($DEBUG_LOW, "reopenCmd()");
    my @arguments = @_;

    # check command arguments
    if (scalar(@arguments) < 1 || (scalar(@arguments) == 1 && $arguments[0] eq "-n")) {
        $cmd{"help"}->("reopen", "'git-fool reopen' parameters mismatch", 255);
    }

    # prepare arguments
    my @headArguments = ();
    if ($arguments[0] eq "-n") {
        $arguments[1] = "^".$arguments[1];
        push(@headArguments, shift(@arguments));
    }
    else {
        $arguments[0] = "^".$arguments[0];
    }
    push(@headArguments, $ISSUE_STATES{"open"});

    # now call stateCmd() it will do the rest
    $cmd{"state"}->(@headArguments, @arguments);
}


# remove existing issue
sub rmCmd {   # rm <tag> [<patterns>]
    DEBUG($DEBUG_LOW, "rmCmd()");

    my @arguments = @_;

    # check command arguments
    if (scalar(@arguments) < 1) {
        $cmd{"help"}->("rm", "'git-fool rm' parameters mismatch", 255);
    }

    # prepare arguments
    $arguments[0] = "^".$arguments[0];

####################################
    testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)

    # read issues file
    my @issuesFileContent = readFile($issuesFile);
    if (!@issuesFileContent) {
        printf("issue file is empty!\n");
        return;
    }

    # find candidates
    my $foundListRef = matchPatterns(\@issuesFileContent, \@arguments);
####################################

    # if only one element found print it always long
    if (scalar(@{$foundListRef}) == 0) {
        EXIT(255, "given issue not found");
    }
    elsif(scalar(@{$foundListRef}) > 1) {
        ERROR("more than one issue matches, please restrict search\n");
        printIndexedIssueList(\@issuesFileContent, $foundListRef, 0);
        EXIT(255);
    }

    # now take the only candidate
    my $lineIndex = ${$foundListRef}[0];

    # prepare user directory if necessary because we need it for the temp file
    prepareUserDir();

    # prepare necessary strings (for HISTORY because for the issue we take all information from the issue itself otherwise a user cannot change an issue from another sb. else!)
    prepareEmail(1);
    prepareUserName(1);

    # print issue to screen
    printf("remove...\n");
    printIssue($issuesFileContent[$lineIndex], 0, 1);
    printf("\n");

    # now scan and handle line
    my $line = $issuesFileContent[$lineIndex];
    if ($line =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/) {
        # process with line elements
        my ($issueValue, $issueUserName, $issueEmail, $issueType, $issueState, $issueMilestone, $issueTitle) = ($1, $2, $3, $4, $5, $6, $7);

        # read tagged file
        my ($certainIssueFileName, $certainIssueFile) = getFileName($FILE_NAME_CERTAIN_ISSUE, $issueValue, $issueUserName, $issueEmail);
        my %tagHash = ();
        if ($certainIssueFile && -s $certainIssueFile) {
            %tagHash = readTaggedFile($certainIssueFile);
        }

        # fill issue line into comment/HISTORY file for backup
        $tagHash{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_BACKUP}} = [$line];

        # write backup file
        my ($backupIssueFileName,  $backupIssueFile)  = getFileName($FILE_NAME_BACKUP);
        writeTaggedFile($backupIssueFile, \%tagHash);

        printf("backup file: $backupIssueFile\n");

        # delete issue from issues file and write it back
        delete($issuesFileContent[$lineIndex]);
        writeFile($issuesFile, \@issuesFileContent);

        # remove comment/HISTORY file if exists otherwise show error message
        if (!($certainIssueFile && -s $certainIssueFile)) {
            EXIT(255, "issue removed but no comment/history file found: $certainIssueFile");    # @todo: implement autorepair function!?
        }
        unlink($certainIssueFile);
    }
    else {
        EXIT(255, "found damaged line in issue file: [$line]");                                 # @todo: implement autorepair function!?
    }
}


# change default milestone or update milestones from existing issues
sub milestoneCmd {   # milestone [<mlst> [<pattern>]]
    DEBUG($DEBUG_LOW, "milestone()");

    my @arguments = @_;

    testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)
    prepareUserDir();   # may be we have to create the user directory if this is the first time current user calls 'new' command

    # prepare necessary strings (for user file change and for HISTORY entries)
    prepareEmail(1);
    prepareUserName(1);
    prepareCheckout(1);

    # reading milestone from user file
    my @userFileContent = readFile($userFile);
    
    # get last issue value from "git config"
    my $currentIssueValue = getIssueValue();

    # checking milestone read from file
    if (!length($userFileContent[$USER_FILE_MILESTONE])) {
        EXIT(255, "$userFile contains invalid milestone value!");                               # @todo: implement autorepair function!?
    }

    # remember current milestone
    my $oldMilestone = $userFileContent[$USER_FILE_MILESTONE];

    # now handle arguments
    my $updatePattern = undef;
    if (scalar(@arguments) == 0) {
        printf("default milestone is [$userFileContent[$USER_FILE_MILESTONE]]\n");
        return;
    }
    my $newMilestone = shift(@arguments);
    normalizeString(\$newMilestone);

    # new milestone valid?
    if (!length($newMilestone)) {
        EXIT(255, "given milestone is invalid, it cannot be empty");
    }

    # if new and old milestones identical don't write user file
    if ($newMilestone ne $oldMilestone) {
        # update milestone value
        $userFileContent[$USER_FILE_MILESTONE] = $newMilestone;

        # user info
        printf("milestone changed from [$oldMilestone] to [$newMilestone]\n");

        # update .fool/<user>/<email> file
        writeFile($userFile, \@userFileContent);
    }
    else {
        # user info
        printf("default milestone not changed because old and new milestones are identical\n");
    }

    # leave if -u is not given
    return if(!scalar(@arguments));

####################################
    #testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)

    # read issues file
    my @issuesFileContent = readFile($issuesFile);
    if (!@issuesFileContent) {
        printf("issue file is empty!\n");
        return;
    }

    # find candidates
    my $foundListRef = matchPatterns(\@issuesFileContent, \@arguments);
####################################

    # check if issue found
    if (scalar(@{$foundListRef}) == 0) {
        EXIT(255, "given issue not found");
    }

    # set to 1 if any issue has been changed (only if it's 1 the issues file will be written back)!
    my $issueChanged = 0;

    foreach my $lineIndex (@{$foundListRef}) {
        # now scan and handle line
        my $line = $issuesFileContent[$lineIndex];

        if ($line =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/) {
            # process with line elements
            my ($issueValue, $issueUserName, $issueEmail, $issueType, $issueState, $issueMilestone, $issueTitle) = ($1, $2, $3, $4, $5, $6, $7);

            # check if issue is not closed because closed ones won't be changed
            if ($issueState eq $ISSUE_STATES{"closed"} || $newMilestone eq $issueMilestone) {
                next;
            }

            # first replace found so print user message
            if (!$issueChanged) {
                printf("change milestones...\n\n");
            }

            # change issue's milestone
            $issuesFileContent[$lineIndex] = createIssueEntry(getIssueTag($issueValue, $issueUserName, $issueEmail), $issueType, $issueState, $newMilestone, $issueTitle);

            # print changed issue to screen
            printIssue($issuesFileContent[$lineIndex], 0, !$issueChanged);
            $issueChanged = 1;

            # read HISTORY file
            my ($certainIssueFileName, $certainIssueFile) = getFileName($FILE_NAME_CERTAIN_ISSUE, $issueValue, $issueUserName, $issueEmail);
            my %tagHash = ();
            if ($certainIssueFile && -s $certainIssueFile) {
                %tagHash = readTaggedFile($certainIssueFile);
            }
            else {
                ERROR("issue changed but no comment/history file found: $certainIssueFile");    # @todo: implement autorepair function!?
            }

            # add comment and write HISTORY file back
            addHistory($HISTORY_TOKEN_CHANGED, \%tagHash);
            writeTaggedFile($certainIssueFile, \%tagHash);
        }
    }

    # write back issues file if necessary
    if ($issueChanged) {
        writeFile($issuesFile, \@issuesFileContent);
    }
    else {
        printf("no issues found to set new milestone\n");
    }
}


# print help screen
sub helpCmd { # help
    DEBUG($DEBUG_LOW, "helpCmd()");
    my ($command, $error, $exitCode) = @_;

    my $FOOL_HEADER     =  "git-fool v0.2 (c) 2014 Manfred Hauser / git\@74th.de under the terms of GPLv2 or newer\n".
                           "usage: git-fool <command> [<args>]\n";

    my $COMMANDS_HEADER =  "Commands:\n";

    my @COMMANDS_HELP   = ("  init                                    prepare current git repository for beeing used with git-fool.\n"                  ,
                           "  new [-c|-p] <title>                     create new issue, opionally give -c(omment and parameters) or\n".
                           "                                            -p(arameters) only\n"                                                           ,
                           "  grep [-a] [-m|-l] [<pattern(s)>]        list all open issues that match with all given patterns, short, -m(edium)\n".
                           "                                            or -l(ong). The issues file and comment files are grepped. If necessary\n".
                           "                                            escape characters, e.g. a \'.\', and sometimes single quotation\n".
                           "                                            marks are necessary, e.g. \'0\.3\'. Comments aren\'t grepped but\n".
                           "                                            email addresses!\n".
                           "                                            To include closed issues as well use optional parameter -a(ll)\n"               ,
                           "  ls [-a] [-m|-l] [<tag> [<pattern(s)>]]  show all open issues that matches tag and all patterns, short (default),\n".
                           "                                            -m(edium) or -l(ong). Given tag will be handled as prefix so usually not\n".
                           "                                            the whole issue is necessary, e.g. \'1/3DES/git\@74th.de\', \'1/3D\' and\n".
                           "                                            even \'1\', all futher given parameters are used for grepping.\n".
                           "                                            To include closed issues as well use optional parameter -a(ll)\n"               ,
                           "  edit [-c|-p] <tag> [<pattern(s)>]       edit open issue \'tag\', tag can be a prefix but issue must be unique.\n".
                           "                                            Edit only -c(omments) or only -p(arameters) or both\n"                          ,
                           "  cp [-n] <tag> [<pattern(s)>]            copy issue \'tag\', tag can be a prefix but issue must be unique.\n".
                           "                                            After copy new issue can be edited if not switched off with -n(o edit).\n"      ,
                           "  mv [-n] <tag> [<pattern(s)>]            copy issue \'tag\' to new issue with current user / current tag.\n".
                           "                                            \'tag\' can be a prefix but issue must be unique. After copy is done, the\n".
                           "                                            original issue is closed and the new one can be edited if not switched off\n".
                           "                                            with -n(o edit).\n"                                                             ,
                           "  rm <tag> [<pattern(s)>]                 remove issue \'tag\', tag can be a prefix but issue must be unique.\n".
                           "                                            A single backup file will be written in fools user directory.\n"                ,
                           "  close [-n] <tag> [<pattern(s)>]         close open issue \'tag\', tag can be a prefix but issue must be unique.\n".
                           "                                            Before closed issue can be edited if not switched off with -n(o edit).\n"       ,
                           "  reopen [-n] <tag> [<pattern(s)>]        reopen issue \'tag\', tag can be a prefix but issue must be unique.\n".
                           "                                            After reopened issue can be edited if not switched off with -n(o edit).\n".
                           "                                            In most cases it\'s better to copy instead of reopening!\n"                     ,
                           "  state [-n] <state> [<pattern(s)>]       sets state of matched issue to state, issue must be unique.\n".
                           "                                            During state change issue can be edited if not switched off with -n(o edit).\n".
                           "                                            Similar to \'git-fool close/reopen\' but only patterns, no tag.\n"              ,
                           "  milestone [<mlst> [<pattern(s)>]]       without any parameter default milestone is shown, given mlst will\n".
                           "                                            be set as new default milestone. With given patterns all open issues\n".
                           "                                            that match will be updated to new milestone.\n".
                           "                                            A \'\"\"\' pattern matches every milestone and updates all open issues.\n"      ,
                           "  help [command]                          show this help screen or only that for command if given.\n"                    );

    my %COMMANDS_INDEX  = ("init"      => 0,
                           "new"       => 1,
                           "grep"      => 2,
                           "ls"        => 3,
                           "edit"      => 4,
                           "cp"        => 5,
                           "mv"        => 6,
                           "rm"        => 7,
                           "close"     => 8,
                           "reopen"    => 9,
                           "state"     => 10,
                           "milestone" => 11,
                           "help"      => 12);


    my $COMMENTS        =   "Comments:\n".
                            "  A full tag looks like this: <counter>/<user>/<email> and therefore is unique otherwise it would conflict\n".
                            "    with several developers.\n".
                            "  If a command needs a tag the given value will be used as prefix of the issues\' tags\n".
                            "    e.g. for an issue tag \'42/3DES/git\@74th.de\' \'42\', \'42/3\' or \'42/3DES/git\' would be valid prefixes.\n".
                            "  If a command needs one or several patterns they will be used to grep through the whole issue, tag included,\n".
                            "    but without comments.\n".
                            "  pattern(s) means one or many, e.g. \'git-fool edit\' can be called e.g. \'git fool edit <pattern> <pattern> ...\'\n".
                            "  All tags and patterns are handled as regular expressions, and an expected tag can be empty, e.g. \"\"!\n".
                            "  Called commands cannot be made undone, but remember we are inside a repository, and this is a job for git!\n".
                            "  Do not write section like text into comments (e.g. \'[foobar]\'), they will be stored fine but won\'t be\n".
                            "    editable anymore with git-fool default option, you have to edit it into text editor!\n";

    my $SETTINGS        =   "Settings (within git):\n".
                            "  mandatory:\n".
                            "    user.name                    developers name\n".
                            "    user.email                   developers email\n".
                            "  optional:\n".
                            "    core.editor                  for issue comment (default is \'vi\');\n";

    if (defined($error)) {
        ERROR("$error\n");
    }

    printf("$FOOL_HEADER\n");

    if (defined($command) && defined($COMMANDS_INDEX{$command})) {
        printf("$COMMANDS_HELP[$COMMANDS_INDEX{$command}]\n");
    }
    else {
        foreach my $help (@COMMANDS_HELP) {
            printf("$help");
        }
        printf("\n");
        printf("$COMMENTS\n");
        printf("$SETTINGS\n");
    }

    if ($exitCode) {
        EXIT($exitCode);
    }
}


sub dosth {
    my ($ref) = @_;
    
    print ref($ref)."\n";
    
    if (ref($ref) eq "ARRAY") {
        printf("got array\n");
    }
    if (ref($ref) eq "SCALAR") {
        printf("got scalar\n");
    }
}

# just for testing...
sub dummyCmd {
    DEBUG($DEBUG_MED, "dummyCmd()");

    $cmd{"help"}->();
}






#########################################
############## main() ###################
#########################################
my $cmd      = shift(@ARGV);    # first element of @ARGV is fool's command!

if (!defined($cmd)) {
    $cmd = "";
}
if ($cmd{$cmd}) {
    DEBUG($DEBUG_LOW, "valid command given");
    $cmd{$cmd}->(@ARGV);
}
else {
    DEBUG($DEBUG_LOW, "given command [$cmd] invalid");
    $cmd{"help"}->("", "missing or unknown command", 255);
}


# @todo: there is many duplicated code... not everywhere but at least at some positions it could be better to remove it!?
# @todo: see all todos (autorepair...)

