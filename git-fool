#!/usr/bin/env perl

use strict;
use warnings;
use Git::Repository;
use Data::Dumper;
use Cwd;
use Getopt::Long;
use POSIX;
use Term::ReadKey;
use File::Path;


# debug stuff
my $DEBUG_NONE  = 0;
my $DEBUG_LOW   = 1;
my $DEBUG_MED   = 2;
my $DEBUG_HIGH  = 3;
my $DEBUG       = $DEBUG_NONE;


# defined issue types
my $ISSUE_TYPE_TASK     = 0;
my $ISSUE_TYPE_BUG      = 1;
my $ISSUE_TYPE_DEFAULT  = $ISSUE_TYPE_TASK;
# no duplicated issues here and no gaps between the issues!!!
my %ISSUE_TYPES = ( $ISSUE_TYPE_TASK    => "Task",
                    $ISSUE_TYPE_BUG     => "Bug",
                  );
my $ISSUE_TYPES_LENGTH = 4+2;       # means length("[Task]") = 4+2


# define states
my %ISSUE_STATES = ( "open"   => "open",
                     "closed" => "closed",
                   );
my $ISSUE_STATES_LENGTH = 6+2;      # means length("[closed]") = 6+2


# some necessary global variables
my $repository = Git::Repository->new();


# some possibly necessary global variables (because of performance only filled when needed!)
my $mainPath          = "";         # git repository main path (where .git can be found)
my $foolPath          = "";         # $mainPath/.fool
my $userPath          = "";         # $foolPath/<user>  (= $mainPath/.fool/<user>)

my $userFile          = "";         # $userPath/<email> (= $mainPath/.fool/<user>/<email>)
my $issuesFile        = "";         # $foolPath/issues (= $mainPath/.fool/issues)

my $checkout          = "";         # current checkout

my $userName          = "";         # user.name
my $shortUserName     = "";         # first two characters of user.name (necessary for files and directories but not for issue file entry!)
my $email             = "";         # user.email
my $editor            = "";         # core.editor


# for cmd handling
my %cmd = ("init"      => \&initCmd,           # $cmd{"init"}->(...)
           "new"       => \&newCmd,
           "grep"      => \&grepCmd,
           "ls"        => \&lsCmd,
           "edit"      => \&editCmd,
           "cp"        => \&cpCmd,
           "close"     => \&closeCmd,
           "reopen"    => \&reopenCmd,
           "rm"        => \&rmCmd,
           "milestone" => \&milestoneCmd,
           "help"      => \&helpCmd,
           "dummy"     => \&dummyCmd,
          );


# define file names
my $FILE_NAME_ISSUES        = 0;
my $FILE_NAME_TEMP          = 1;
my $FILE_NAME_CERTAIN_ISSUE = 2;
my $FILE_NAME_CURRENT_ISSUE = 3;
my $FILE_NAME_USER          = 4;
my %FILE_NAMES = ( $FILE_NAME_ISSUES            =>    "issues",
                   $FILE_NAME_TEMP              =>    ".temp",
                   $FILE_NAME_CERTAIN_ISSUE     =>    "",              # to be filled during runtime, user name and email are necessary that are not known atm.
                   $FILE_NAME_CURRENT_ISSUE     =>    "",              # to be filled during runtime, user name and email are necessary that are not known atm.
                   $FILE_NAME_USER              =>    "",              # to be filled during runtime, user name and email are necessary that are not known atm.
                  );



# define history file sections
my $HISTORY_FILE_SECTION_NONE    = 0;
my $HISTORY_FILE_SECTION_HISTORY = 1;
my %HISTORY_FILE_SECTIONS = ( $HISTORY_FILE_SECTION_NONE      =>  "none",
                              $HISTORY_FILE_SECTION_HISTORY   =>  "[HISTORY]",
                           );
       


# define history tokens
my $HISTORY_TOKEN_CREATED   = 0;
my $HISTORY_TOKEN_COPIED    = 1;
my $HISTORY_TOKEN_CHANGED   = 2;
my $HISTORY_TOKEN_CLOSED    = 3;
my $HISTORY_TOKEN_REOPENED  = 4;
my $HISTORY_TOKEN_REPAIRED  = 5;
my %HISTORY_TOKENS = ( $HISTORY_TOKEN_CREATED   =>  "CREATED:  ",   # usually first entry in history file
                       $HISTORY_TOKEN_COPIED    =>  "COPIED:   ",   # if this exists in history file it's usually the first entry because it's a copy of another issue
                       $HISTORY_TOKEN_CHANGED   =>  "CHANGED:  ",
                       $HISTORY_TOKEN_CLOSED    =>  "CLOSED:   ",
                       $HISTORY_TOKEN_REOPENED  =>  "REOPENED: ",
                       $HISTORY_TOKEN_REPAIRED  =>  "REPAIRED: ",   # if this exists in history file it's usually the first entry because original file has been lost
                     );


# define user file elements
my $USER_FILE_ISSUE_COUNTER = 0;
my $USER_FILE_MILESTONE     = 1;



################################################
############## helper functions ################
################################################
# for a short periode of time CTRL+C should be disabled! @todo
#$SIG{INT} = \&mySIGINT;
sub mySIGINT() {
    printf("CTRL+C not allowed at the moment\n");
    $SIG{INT} = \&mySIGINT;
}


# print string as hex
sub printHex($) {
    my ($string) = @_;

    for (my $i=0; $i<length($string); $i++) {
        printf("%02X ", ord(substr($string, $i, 1)));
    }
    printf("\n");
}


# compares two arrays
sub arraysEqual($$) {
    my ($array1Ref, $array2Ref) = @_;

    return 0 unless @{$array1Ref} == @{$array2Ref};         # return false if #elements are different!

    my $i = 0;
    foreach my $element (@{$array1Ref}) {
        return 0 unless $element eq ${$array2Ref}[$i++];    # return false if at least one element differs
    }

    return 1;                                               # if arrays are identical return true
}


# own chomp() version
sub CHOMP(\$) {
    my ($stringRef) = @_;
    ${$stringRef} =~ s/[\x0A\x0D]+$//;
}


# debug outputs
sub DEBUG($$) {
    my ($level, $message) = @_;
    if ($DEBUG >= $level) {
        printf("DEBUG[$level] - $message\n");
        my ($package, $filename, $line, $subroutine) = caller(0);
        printf("  from $filename".":$line");
        ($package, $filename, $line, $subroutine) = caller(1);
        if ($package && $filename && $line && $subroutine) {
            if (rindex($subroutine, ':')) {
                $subroutine = substr($subroutine, rindex($subroutine, ':')+1);
            }
            printf(" ($subroutine())\n");
        }
        else {
            printf(" (main())\n");
        }
    }
}


# extended exit function
sub EXIT($;$) {
    DEBUG($DEBUG_MED, "EXIT()");
    my ($exitCode, $message) = @_;

    if (defined($message)) {
        if ($exitCode) {
            printf("error: ");
        }
        printf("$message\n\n");
    }
    exit($exitCode);
}


# read user.name from git config
sub prepareUserName($) {
    DEBUG($DEBUG_MED, "prepareUserName()");
    my ($errorHandling) = @_;

    # only if $userName is not yet set because of performance reaseons!
    if (!$userName) {
        $userName = $repository->run("config" => "user.name");

        # user.name must be set to make git fool working!
        if (!$userName && $errorHandling) {
            EXIT(255, "user.name not set in git!");
        }
        $shortUserName = uc(substr($userName, 0, 2));

        # if $shortUserName length is less than 2 $userName length is also less than two but two characters are our minimum so enlarge them!!!
        if (length($shortUserName) < 2) {
            $userName      .= "_";
            $shortUserName .= "_";
        }
    }
}


# read user.email from git config
sub prepareEmail($) {
    DEBUG($DEBUG_MED, "prepareEmail()");
    my ($errorHandling) = @_;

    # only if $email is not yet set because of performance reaseons!
    if (!$email) {
        $email    = $repository->run("config" => "user.email");
        if (!$email && $errorHandling) {
            EXIT(255, "user.email not set in git!");
        }
    }
}


# read core.editor from git config (environments, e.g. GIT_EDITOR will be ignored!)
sub prepareEditor() {
    DEBUG($DEBUG_MED, "prepareEditor()");

    # only if $editor is not yet set because of performance reaseons!
    if (!$editor) {
        $editor   = $repository->run("config" => "core.editor");
        if (!$editor) {
            $editor = "vi";
        }
    }
}


# read current checkout
sub prepareCheckout($) {
    DEBUG($DEBUG_MED, "prepareCheckout()");
    my ($errorHandling) = @_;

    if (!$checkout) {
        $checkout = $repository->run("rev-parse" => "HEAD");
        if (!$checkout && $errorHandling) {
            EXIT(255, "git-fool needs a valid checkout!");
        }
    }
}


# build git-fool system file name
sub getFileName($;@);       # prototyping
sub getFileName($;@) {
    DEBUG($DEBUG_MED, "getFileName()");

    my ($fileType, @parameters) = @_;

    # expects getFileName(FILE_NAME_CURRENT_ISSUE, <latest issue value>)
    if ($fileType == $FILE_NAME_ISSUES) {
        if (scalar(@parameters) != 0) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }

        my $fileName = $FILE_NAMES{$fileType};
        return ($fileName, $foolPath."/".$fileName);
    }
    elsif ($fileType == $FILE_NAME_TEMP) {
        if (scalar(@parameters) != 0) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }
        prepareEmail(1);

        my $fileName = $FILE_NAMES{$fileType};
        return ($fileName, $userPath."/".$email.$fileName);
    }
    elsif ($fileType == $FILE_NAME_CERTAIN_ISSUE) {
        if (scalar(@parameters) != 3) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }
        my ($issueValue, $userName, $email) = @parameters;

        my $fileName = ".".join("_", ($issueValue, $userName, $email));
        return ($fileName, $foolPath."/".$fileName);
    }
    elsif ($fileType == $FILE_NAME_CURRENT_ISSUE) {
        if (scalar(@parameters) != 1) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }
        my ($issueValue) = @parameters;
        prepareUserName(1);
        prepareEmail(1);

        return getFileName("$FILE_NAME_CERTAIN_ISSUE", $issueValue, $userName, $email);
    }
    elsif ($fileType == $FILE_NAME_USER) {
        if (scalar(@parameters) != 0) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }

        return ($email, $userPath."/".$email);
    }
    else {
        EXIT(254, "internal error - not handled file type: $fileType");
    }
}

# find main directory that contains ".git" and if initialization is already done also ".fool"
sub findRepoMainDir() {
    DEBUG($DEBUG_MED, "findRepoMainDir()");
    $mainPath = cwd();
    while (!(-d $mainPath."/.git")) {
        $mainPath = substr($mainPath, 0, rindex($mainPath, '/'));
        if (!$mainPath) {
            EXIT(255, "not inside a git repository!");
        }
    }
}


# fill $foolPath and $issuesFile variables
sub setFoolDir() {
    DEBUG($DEBUG_MED, "findFoolDir()");

    # get repo main path if not already set
    if (!$mainPath) {
        findRepoMainDir();
    }

    $foolPath   = $mainPath."/.fool";
    $issuesFile = getFileName($FILE_NAME_ISSUES);
}


# fill $userPath and $userFile variables
sub setUserDir() {
    DEBUG($DEBUG_MED, "findUserDir()");

    prepareEmail(1);
    prepareUserName(1);

    # get fool path if not already set
    if (!$foolPath) {
        setFoolDir();
    }

    $userPath    = $foolPath."/".$shortUserName;
    $userFile    = getFileName($FILE_NAME_USER);
}


# test if .fool directory exists
sub testFoolDir() {
    DEBUG($DEBUG_MED, "testFoolDir()");

    if (!$foolPath) {
        setFoolDir();
    }

    if (!(-d $foolPath) || !(-e $issuesFile)) {
        EXIT(255, "git-fool seems not to be initialized, run 'git-fool init'!");
    }
}


# test if .fool directory exists
sub testUserDir() {
    DEBUG($DEBUG_MED, "testUserDir()");

    if (!$userPath) {
        setUserDir();
    }

    if (!(-d $userPath) || !(-e $userFile)) {
        EXIT(255, "git-fool user path not initialized, run 'git-fool new'!");
    }
}


# prepare .fool directory
sub prepareFoolDir() {
    DEBUG($DEBUG_MED, "prepareFoolDir()");

    # find main directory of current repository and set $foolPath variable
    setFoolDir();

    # create .fool path if not exists
    if (!(-d $foolPath)) {
        mkdir($foolPath) || EXIT(255, "cannot create directory $foolPath: $!");
    }

    # create .fool/issues file if not exists
    if (!(-e getFileName($FILE_NAME_ISSUES))) {
        my ($fileName, $file) = getFileName($FILE_NAME_ISSUES);
        createFile($file);
    }
}


# prepare .fool/<user> directory and .fool/<user>/<email> file
sub prepareUserDir() {
    DEBUG($DEBUG_MED, "prepareUserDir()");

    # find user directory
    setUserDir();

    # create user directory if not exists
    if (!(-d $userPath)) {
        mkpath($userPath) || EXIT(255, "cannot create directory $userPath: $!");;
    }

    # create .fool/<user>/latest if doesn't exist and fill it with 0 otherwise let it untouched
    if (!(-e $userFile)) {
        writeFile($userFile, ["0", "0.1"]);
    }
}


# creates a short issue tag from given parameters (issue value and user name)
sub getShortIssueTag($$) {
    DEBUG($DEBUG_MED, "getShortIssueTag()");
    my ($issueValue, $userName) = @_;

    return ($issueValue."/".$userName);
}


# create an issue tag from given parameter and current global value
sub getCurrentShortIssueTag($) {
    DEBUG($DEBUG_MED, "getCurrentShortIssueTag()");
    my ($issueValue) = @_;

    return getShortIssueTag($issueValue, $userName);
}


# creates an issue tag from given parameters (issue value, user name and email address)
sub getIssueTag($$$) {
    DEBUG($DEBUG_MED, "getCurrentShortIssueTag()");
    my ($issueValue, $userName, $email) = @_;

    return (getShortIssueTag($issueValue, $userName)."/".$email);
}


# create an issue tag from given parameter and current global values
sub getCurrentIssueTag($) {
    DEBUG($DEBUG_MED, "getCurrentShortIssueTag()");
    my ($issueValue) = @_;

    return getIssueTag($issueValue, $userName, $email);
}


# create user id from given parameters (user name and email address)
sub getUserId($$) {
    DEBUG($DEBUG_MED, "getUserId()");
    my ($userName, $email) = @_;

    return ($userName."/".$email);
}


# create user id from current user
sub getCurrentUserId() {
    DEBUG($DEBUG_MED, "getCurrentUserId()");
    prepareEmail(1);
    prepareUserName(1);

    return getUserId($userName, $email);
}


# inserts a given string into HISTORY section in a given tag hash
sub addHistory($$;$) {
    DEBUG($DEBUG_MED, "addHistory()");
    my ($token, $tagHashRef, $comment) = @_;

    if (!${$tagHashRef}{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}}) {
        ${$tagHashRef}{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}} = [];
    }

    if (!$HISTORY_TOKENS{$token}) {
        EXIT(254, "history token [$token] doesn't exist!");
    }

    my $entry = $HISTORY_TOKENS{$token}.strftime("UTC, %b %e %H:%M:%S %Y", gmtime())." -by- ".getCurrentUserId()." -at- $checkout";       # @todo: branch/tag ermitteln und angeben, falls so einer existiert was nicht immer der Fall ist, z.B. wenn origin/master oder der hash zum auschecken verwendet wurde. gehen tut das mit (Fehlerprüfung git-versions-prüfung (>=1.8 vermutlich) nicht vergessen!): git symbolic-ref -q --short HEAD || git describe --tags --exact-match
    if (defined($comment)) {
        $entry .= " - $comment";
    }

    push(@{${$tagHashRef}{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}}}, $entry);
}


# create issue entry
sub createIssueEntry($$$$$) {
    DEBUG($DEBUG_MED, "createIssueEntry()");
    my ($issueTag, $issueType, $issueState, $milestone, $issueTitle) = @_;

    return "$issueTag/$issueType/$issueState/$milestone/$issueTitle";
}


# reads a string file into an array
sub readFile($) {
    DEBUG($DEBUG_MED, "readFile()");
    my ($fileName) = @_;

    my @fileContent = ();

    if (-e $fileName) {
        my $FH;
        open($FH, "<", $fileName) || EXIT(255, "cannot open $fileName: $!");
        while (<$FH>) {
            CHOMP($_);
            push(@fileContent, $_);
        }
        close($FH);
    }
    else {
        printf("error: file $fileName doesn't exist!\n");   # if file doesn't exist show error message but don't stop processing otherwise whole issue tracking won't work anymore if one file is missing!
    }

    return @fileContent;
}


# writes content of a given array ref into a file
sub writeFile($$) {
    DEBUG($DEBUG_MED, "writeFile()");

    my ($fileName, $linesRef) = @_;

    my $FH;
    open($FH, ">", $fileName) || EXIT(255, "cannot open $fileName: $!");

    foreach my $line (@{$linesRef}) {
        print($FH $line."\n");
    }
    close($FH);
}


# adds given lines to an existing file if it doesn't exist it will be created
sub appendFile($$) {
    DEBUG($DEBUG_MED, "appendFile()");
    my ($fileName, $linesRef) = @_;

    my $FH;
    open($FH, ">>", $fileName) || EXIT(255, "cannot open $fileName: $!");

    foreach my $line (@{$linesRef}) {
        print($FH $line."\n");
    }
    close($FH);
}


# creates an empty file, an existing one will be overwritten
sub createFile($) {
    DEBUG($DEBUG_MED, "createFile()");
    
    my ($fileName) = @_;
    
    writeFile($fileName, []);
}


# writes a given tag hash to a file (first writes optional leading tagless sections followed by optional tagged sections, tag means [<tag>])
sub writeTaggedFile($$) {
    DEBUG($DEBUG_MED, "writeTaggedFile()");
    my ($fileName, $fileContentRef) = @_;

    # sub function for writing single body sections to prefent code duplication!
    my $subFunction = sub {
        my ($FH, $linesRef) = @_;

        my $lastLine = "";

        # now write all lines from current section
        foreach my $line (@{$linesRef}) {
            print($FH $line."\n");
            $lastLine = $line;
        }

        # ensure to have at least one empty line between sections
        if ($lastLine) {
            print($FH "\n");
        }
    };

    my $FH;
    open($FH, ">", $fileName) || EXIT(255, "cannot open $fileName: $!");

    # print tagless section (only body without any tag) at the beginning
    if (${$fileContentRef}{"none"}) {
        $subFunction->($FH, ${$fileContentRef}{"none"});
        delete(${$fileContentRef}{"none"});
    }

    # now print all other sections
    foreach my $key (sort(keys(%{$fileContentRef}))) {
        # print section tag
        print($FH $key."\n");
        my $lastLine = "";

        # print section body
        $subFunction->($FH, ${$fileContentRef}{$key});
    }

    close($FH);
}


# read whole tagged string file (means file with an optional leading tagless sections followed by optional tagged sections, tag means [<tag>])
sub readTaggedFile($) {
    DEBUG($DEBUG_MED, "readTaggedFile()");
    my ($fileName) = @_;

    my @lines = readFile($fileName);

    my %tagHash = ("none" => []);

    my $currenTag = "none";
    foreach my $line (@lines) {
        CHOMP($line);

        # tag line found?
        if ($line =~ /^(\[[^]]+\])$/) {
            $currenTag = $1;
            $tagHash{$currenTag} = [];           # create new tag entry in tag hash
            next;                                   # line handled take next one
        }

        push(@{$tagHash{$currenTag}}, $line);    # if not a tag line push it into current tag content array
    }

    foreach my $section (keys(%tagHash)) {
        while ($tagHash{$section} && scalar(@{$tagHash{$section}}) && !length(${$tagHash{$section}}[-1])) {  # remove latest lines as long as they are empty ones
            pop(@{$tagHash{$section}});
        }
    }

    return %tagHash;
}


# if given string is longer than given size string will be cut and an ellipse will be added
sub shortenString($$) {
    DEBUG($DEBUG_MED, "shortenString()");
    my ($string, $size) = @_;

    if (length($string) > $size) {
        $string = substr($string, 0, $size-3)."...";
    }

    return $string;
}


#
sub printIssue($$$) {
    DEBUG($DEBUG_MED, "printIssue()");
    my ($line, $long, $alreadyWritten) = @_;

    my ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();

    # some variables to make later changes little bit easier!
    my $milestoneLength   = 9;
    my $idLength          = 6;
    my $userNameLength    = 10;         # @todo: da es evtl. nervt, wenn der username nicht vollständig angezeigt wird, das auf ein git config element legen!
    my $defaultTileLength = 35;
    my $maxTitleLength    = $wchar - 50; # depends on window size
    if ($maxTitleLength < 10) {
        $maxTitleLength = $defaultTileLength;   # if window is too small for printing the title ignore window size and print the whole title
    }

    # issue line has to be printed
    if ($line =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/) {
        # process with line elements
        my ($id, $userName, $email, $issueType, $state, $milestone, $title) = ($1, $2, $3, $4, $5, $6, $7);

        # do some string formattings (to shorten the output to screen width if not option -l is used!)
        my $userNamePrepared  =      shortenString($userName,           $userNameLength);
        my $titlePrepared     = "\"".shortenString($title,              $maxTitleLength-2)     ."\"";      # -2 because of the quotation marks "<text>"
        my $issueTypePrepared =      shortenString($issueType,          $ISSUE_TYPES_LENGTH);
        my $statePrepared     =      shortenString($state,              $ISSUE_STATES_LENGTH);
        my $milestonePrepared = "\"".shortenString($milestone,          $milestoneLength-2)    ."\"";      # -2 because of the brackets [<MLST>]

        # now print the stuff
        if (!$long) {   # print each issue into one line as long as the window is not too smal otherwise line will be printed uncut (see calculation of $maxTitleLength)
            # if not -l print a header line
            if (!$alreadyWritten) {
                printf("%-".($idLength+$userNameLength+1)."s %-".$maxTitleLength."s %-".$ISSUE_TYPES_LENGTH."s %-".$ISSUE_STATES_LENGTH."s %s\n", "ISSUE", "TITLE", "TYPE", "STATE", "MILESTONE");
                printf(("-" x (45+$maxTitleLength))."\n");
            }

            printf("%-".($idLength+$userNameLength+1)."s %-".$maxTitleLength."s %-".$ISSUE_TYPES_LENGTH."s %-".$ISSUE_STATES_LENGTH."s %s\n", getShortIssueTag($id, $userNamePrepared), $titlePrepared, $issueTypePrepared, $statePrepared, $milestonePrepared);
        }
        else {          # if -l parameter is given the issue line is printed uncut in any case
            # if this is not the first line to be printed print a ############### separator line
            if ($alreadyWritten) {
                printf(("#" x (45+$maxTitleLength))."\n\n");
            }

            # now print header line
            printf("Issue     : %s\n".
                   "Title     : %s\n".
                   "Type      : %s\n".
                   "State     : %s\n".
                   "Milestone : %s\n\n", getIssueTag($id, $userName, $email), $title, $issueType, $state, $milestone);

            # now try to print the comment/HISTORY file
            my $certainIssueFile   = getFileName($FILE_NAME_CERTAIN_ISSUE, $id, $userName, $email);

            my @commentHistoryFile = readFile($certainIssueFile);
            foreach my $line (@commentHistoryFile) {
                printf("$line\n");
            }
        }
    }
    else {
        EXIT(255, "found damaged line in issue file: [$line]");
    }
}


#
sub normalizeString(\$) {
    my ($titleRef) = @_;

    CHOMP($titleRef);
    ${$titleRef} =~ s/[\x00-\x1F\x7F]//g;   # replace not allowed characters from string
    ${$titleRef} =~ s/(^(\")+|(\")+$)//g;   # replace quotation mark at beginning and end of the string
    ${$titleRef} =~ s/\//_/g;               # slash (/) is not allowed inside e.g. the title so replace all of them by underscore (_)

}





################################################
############## fool commands ###################
################################################


# initialize git repository for git-fool (.fool folder will be created)
sub initCmd {
    DEBUG($DEBUG_LOW, "initCmd()");

    # prepare fool dir if necessary
    prepareFoolDir();
}


# create new issue
sub newCmd {  # new [-c|-p] <title>
    DEBUG($DEBUG_LOW, "newCmd()");
    my @arguments = @_;

    # check command arguments
    if (scalar(@arguments) < 1 || (scalar(@arguments) == 1 && ($arguments[0] eq "-c" || $arguments[0] eq "-p"))) {
        $cmd{"help"}->("'git-fool new' parameters mismatch", 255);
    }

    testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)
    prepareUserDir();   # may be we have to create the user directory if this is the first time current user calls 'new' command

    # reading latest issue value from file (file contains only this one line!)
    my @userFileContent = readFile($userFile);
    if ($userFileContent[$USER_FILE_ISSUE_COUNTER] !~ /^\d+$/) {
        EXIT(255, "$userFile contains invalid latest value!");
    }
    $userFileContent[$USER_FILE_ISSUE_COUNTER]++; # increment for current issue

    # reading milestone value from file (file contains only this one line!)
    if (!$userFileContent[$USER_FILE_MILESTONE]) {
        EXIT(255, "$userFile contains invalid milestone value!");
    }

    my $tempFile  = "";
    my $issueType = $ISSUE_TYPE_DEFAULT;

    if ($arguments[0] eq "-c" || $arguments[0] eq "-p") {
        # reading milestrom from user input
        printf("Milestone [$userFileContent[$USER_FILE_MILESTONE]]: ");     # pressing just [ENTER] doesn't change default milestone
        my $newMilestone = <STDIN>;         # read new milestone
        normalizeString($newMilestone);     # make a clean string out of it
        if ($newMilestone) {
            $userFileContent[$USER_FILE_MILESTONE] = $newMilestone;
        }

        # reading issue type from user input
        while(1) {
            printf("issue type: ");
            my $counter = 1;
            foreach my $issue (sort(keys(%ISSUE_TYPES))) {
                printf("$issue-$ISSUE_TYPES{$issue}");
                if ($counter++ < scalar(keys(%ISSUE_TYPES))) {
                    printf(", ");
                }
                else {
                    printf(" [$issueType]: ");  # print default option if user presses just [ENTER]
                }
            }

            my $newIssueType = <STDIN>;
            CHOMP($newIssueType);
            if ($newIssueType =~ /^\d+$/ && $newIssueType >= 0 && $newIssueType < scalar(keys(%ISSUE_TYPES))) {      # valid user input
                $issueType = $newIssueType;
                last;
            }
            elsif (!$newIssueType) {    # just [ENTER]
                last;
            }
            else {  # invalid user input
                printf("issue type $newIssueType is not valid!\n");
            }
        }

        # prepare and run default editor if parameter -c has been given
        if ($arguments[0] eq "-c") {
            prepareEditor();
            $tempFile = getFileName($FILE_NAME_TEMP);
            createFile($tempFile);              # ensure that .fool/<user>/.temp exists and is empty!
            system("$editor $tempFile");        # open editor to edit temp file
        }

        shift(@arguments);      # remove cmd from arguments list because rest is the issue title
    }
    my $issueTypeText = $ISSUE_TYPES{$issueType};

    my $title = join(" ", @arguments);  # create title out of the rest of given arguments
    normalizeString($title);

    if (!(length($title))) {    # after normalization it's possible that given title is empty, e.g. if sth. like '""""""' was given
        EXIT(255, "title cannot be empty!");
    }


    # prepare necessary user strings
    prepareEmail(1);
    prepareUserName(1);
    prepareCheckout(1);

    # if exists read comment file to be handled when comment/HISTORY file is written
    my %tagHash = ();
    if ($tempFile && -s $tempFile) {
        %tagHash = readTaggedFile($tempFile);
    }

    # create comment/history file
    if (!$tagHash{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}}) {
        $tagHash{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}} = [];
    }

    # now write current issue file (with comments and HISTORY)
    addHistory($HISTORY_TOKEN_CREATED, \%tagHash);
    my ($currentIssueFileName, $currentIssueFile) = getFileName($FILE_NAME_CURRENT_ISSUE, $userFileContent[$USER_FILE_ISSUE_COUNTER]);
    writeTaggedFile($currentIssueFile, \%tagHash);

    # comment file content has been written into history file so we can delete it now
    if ($tempFile && -s $tempFile) {
        unlink($tempFile);
    }

    # user info
    printf("created issue ".$currentIssueFileName);

    # update .fool/<user>/<email> file
    writeFile($userFile, \@userFileContent);

    # write issue into issues file
    appendFile($issuesFile, [createIssueEntry(getCurrentIssueTag($userFileContent[$USER_FILE_ISSUE_COUNTER]), $issueTypeText, $ISSUE_STATES{"open"}, $userFileContent[$USER_FILE_MILESTONE], $title)]);
}


# search for certain issues
sub grepCmd {   # grep [-l] [<patterns>]
    DEBUG($DEBUG_LOW, "grepCmd()");
    my @arguments = @_;

    my $long = 0;

    # check command arguments
    if (@arguments && $arguments[0] eq "-l") {
        $long = 1;
        shift(@arguments);
    }

    # test if init has already be done
    testFoolDir();

    # read issues file
    my @issuesFileContent = readFile($issuesFile);
    if (!@issuesFileContent) {
        printf("issue file is empty!\n");
        return;
    }

    # now handle all issues' lines
    my $alreadyWritten = 0;
    foreach my $line (@issuesFileContent) {
        # if <patterns> are given we have to match...
        my $patternFound = 1;
        if (@arguments) {
            foreach my $pattern (@arguments) {
                if ($line !~ /$pattern/) {
                    $patternFound = 0;
                    last;
                }
            }
            next unless ($patternFound);    # if no pattern matched continue with next line...
        }

        printIssue($line, $long, $alreadyWritten);
        $alreadyWritten = 1;
    }
}


# list issue(s)
sub lsCmd { # ls [<issue>]
    DEBUG($DEBUG_LOW, "lsCmd()");
    my @arguments = @_;

    # check command arguments
    if (@arguments > 1) {
        $cmd{"help"}->("'git-fool ls' parameters mismatch", 255);
    }
    if (!@arguments) {
        grepCmd();
        return;
    }

    # test if init has already be done
    testFoolDir();

    # read issues file
    my @issuesFileContent = readFile($issuesFile);
    if (!@issuesFileContent) {
        printf("issue file is empty!\n");
        return;
    }

    # search and if found handle issue
    foreach my $line (@issuesFileContent) {
        if ($line =~ /^$arguments[0]/) {
            printIssue($line, 1, 0);
            return;
        }
    }

    printf("given issue [$arguments[0]] couldn't be matched\n");
}


# edit existing issue
sub editCmd { # edit <issue>
    DEBUG($DEBUG_LOW, "editCmd()");
    my @arguments = @_;

    # check command arguments
    if (@arguments != 1) {
        $cmd{"help"}->("'git-fool edit' parameters mismatch", 255);
    }

    testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)
    prepareUserDir();   # prepare user directory if necessary because we need it for the temp file

    # read issues file
    my @issuesFileContent = readFile($issuesFile);

    # prepare necessary strings (for HISTORY because for the issue we take all information from the issue itself otherwise a user cannot change an issue from another sb. else!)
    prepareEmail(1);
    prepareUserName(1);
    prepareCheckout(1);

    # search for given issue in issue file
    my $lineIndex;
    for ($lineIndex = 0; $lineIndex<@issuesFileContent; $lineIndex++) {
        if ($issuesFileContent[$lineIndex] =~ /^$arguments[0]/) {
            last;   # finish if line matches
        }
    }
    if ($lineIndex == @issuesFileContent) {
        printf("given issue doesn't exist!");
        return;
    }

    # print issue to screen
    printIssue($issuesFileContent[$lineIndex], 0, 0);
    printf("\n");

    # set to 1 if anything of the issue has been changed!
    my $issueChanged = 0;

    # now scan and handle line
    my $line = $issuesFileContent[$lineIndex];
    if ($line =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/) {
        # process with line elements
        my ($id, $userName, $email, $issueType, $state, $milestone, $title) = ($1, $2, $3, $4, $5, $6, $7);

        # reading new title from user input
        printf("Title [$title]:\n");    # pressing just [ENTER] doesn't change original title
        my $newTitle = <STDIN>;         # read new title
        normalizeString($newTitle);
        if (length($newTitle)) {
            $title = $newTitle;
            $issueChanged = 1;
            printf("changed\n");    # @todo: rauswerfen!
        }

        # reading milestone from user input
        printf("Milestone [$milestone]: ");     # pressing just [ENTER] doesn't change default milestone
        my $newMilestone = <STDIN>;   # read new milestone
        CHOMP($newMilestone);
        normalizeString($newMilestone);
        if ($newMilestone) {
            $milestone = $newMilestone;
            $issueChanged = 1;
            printf("changed\n");    # @todo: rauswerfen!
        }

        # find issue type string and convert it into issue type value
        while (my($key, $value) = each %ISSUE_TYPES) {
            if ($value eq $issueType) {
                $issueType = $key;
                last;
            }
        }

        # reading issue type from user input
        while(1) {
            printf("issue type: ");
            my $counter = 1;
            foreach my $issue (sort(keys(%ISSUE_TYPES))) {
                printf("$issue-$ISSUE_TYPES{$issue}");
                if ($counter++ < scalar(keys(%ISSUE_TYPES))) {
                    printf(", ");
                }
                else {
                    printf(" [$issueType]: ");  # print default option if user presses just [ENTER]
                }
            }

            my $newIssueType = <STDIN>;
            CHOMP($newIssueType);
            if ($newIssueType =~ /^\d+$/ && $newIssueType >= 0 && $newIssueType < scalar(keys(%ISSUE_TYPES))) {      # valid user input
                $issueType = $newIssueType;
                $issueChanged = 1;
                printf("changed\n");    # @todo: rauswerfen!
                last;
            }
            elsif (!$newIssueType) {    # just [ENTER]
                last;
            }
            else {  # invalid user input
                printf("issue type $newIssueType is not valid!\n");
            }
        }

        # update issues array and write back issues file if necessary
        if ($issueChanged) {
            $issuesFileContent[$lineIndex] = createIssueEntry(getIssueTag($id, $userName, $email), $ISSUE_TYPES{$issueType}, $state, $milestone, $title);
            writeFile($issuesFile, \@issuesFileContent);
        }

        # read tagged file
        my ($certainIssueFileName, $certainIssueFile) = getFileName($FILE_NAME_CERTAIN_ISSUE, $id, $userName, $email);

        my %tagHash = ();
        if ($certainIssueFile && -s $certainIssueFile) {
            %tagHash = readTaggedFile($certainIssueFile);
        }
        else {
            EXIT(255, "no comment/history file found: $certainIssueFile");      # @todo: evtl. autorepair hier aufrufen?
        }

        # write temp file for beeing edited
        my ($tempFileName, $tempFile) = getFileName($FILE_NAME_TEMP);
        writeFile($tempFile, $tagHash{"none"});

        prepareEditor();
        system("$editor $tempFile");        # open editor to edit temp file

        my @newComments = readFile($tempFile);

        # if anything has been changed recreate comment/history file
        if (!arraysEqual($tagHash{"none"}, \@newComments) || $issueChanged) {
            $tagHash{"none"} = \@newComments;
            addHistory($HISTORY_TOKEN_CHANGED, \%tagHash);
            writeTaggedFile($certainIssueFile, \%tagHash);
        }
        unlink($tempFile);
    }
    else {
        EXIT(255, "found damaged line in issue file: [$line]");
    }
}


# copy existing issue
sub cpCmd {   # cp <issue>
    DEBUG($DEBUG_LOW, "cpCmd()");
    my @arguments = @_;

    # check command arguments
    if (@arguments != 1) {
        $cmd{"help"}->("'git-fool cp' parameters mismatch", 255);
    }

    # check if .fool directory exists (if not init hasn't be called yet!)
    testFoolDir();

    # read issues file
    my @issuesFileContent = readFile($issuesFile);

    # search for given issue in issue file
    my $lineIndex;
    for ($lineIndex = 0; $lineIndex<@issuesFileContent; $lineIndex++) {
        if ($issuesFileContent[$lineIndex] =~ /^$arguments[0]/) {
            last;   # finish if line matches
        }
    }
    if ($lineIndex == @issuesFileContent) {
        printf("given issue doesn't exist!");
        return;
    }

    # prepare user directory if necessary because we need it for the issue's user id
    prepareUserDir();

    # reading latest issue value from file (file contains only this one line!)
    my @userFileContent = readFile($userFile);

    if ($userFileContent[$USER_FILE_ISSUE_COUNTER] !~ /^\d+$/) {
        EXIT(255, "$userFile contains invalid latest value!");
    }
    $userFileContent[$USER_FILE_ISSUE_COUNTER]++; # increment for current issue

    # reading milestone value from file (file contains only this one line!)
    if (!$userFileContent[$USER_FILE_MILESTONE]) {
        EXIT(255, "$userFile contains invalid milestone value!");
    }

    # prepare necessary strings (for HISTORY because for the issue we take all information from the issue itself otherwise a user cannot change an issue from another sb. else!)
    prepareEmail(1);
    prepareUserName(1);
    prepareCheckout(1);

    # now scan and handle line
    my $line = $issuesFileContent[$lineIndex];
    if ($line =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/) {
        # process with line elements
        my ($issueValue, $issueUserName, $issueEmail, $issueType, $state, $issueMilestone, $title) = ($1, $2, $3, $4, $5, $6, $7);

        # update .fool/<user>/<email> file
        writeFile($userFile, \@userFileContent);

        # write issue into issues file (id, user name, email will be set to current user, state will be set to open and current default milestone will be used!)
        appendFile($issuesFile, [createIssueEntry(getIssueTag($userFileContent[$USER_FILE_ISSUE_COUNTER], $userName, $email), $issueType, $ISSUE_STATES{"open"}, $userFileContent[$USER_FILE_MILESTONE], $title)]);

        # read history file from original issue
        my ($certainIssueFileName, $certainIssueFile) = getFileName($FILE_NAME_CERTAIN_ISSUE, $issueValue, $issueUserName, $issueEmail);
        my %tagHash = ();
        if ($certainIssueFile && -s $certainIssueFile) {
            %tagHash = readTaggedFile($certainIssueFile);
        }
        else {
            EXIT(255, "no comment/history file found: $certainIssueFile");      # @todo: evtl. autorepair hier aufrufen?
        }

        # replace original [HISTORY] section
        $tagHash{$HISTORY_FILE_SECTIONS{$HISTORY_FILE_SECTION_HISTORY}} = [];
        addHistory($HISTORY_TOKEN_COPIED, \%tagHash, "from ".getIssueTag($issueValue, $issueUserName, $issueEmail));

        # write history file of new issue
        my ($currentIssueFileName, $currentIssueFile) = getFileName($FILE_NAME_CURRENT_ISSUE, $userFileContent[$USER_FILE_ISSUE_COUNTER]);
        writeTaggedFile($currentIssueFile, \%tagHash);

        editCmd($userFileContent[$USER_FILE_ISSUE_COUNTER]);
    }
    else {
        EXIT(255, "found damaged line in issue file: [$line]");
    }
}


# change issue state to closed
sub closeCmd {    # close <issue>
    DEBUG($DEBUG_LOW, "closeCmd()");
}


# reopen an already closed issue again
sub reopenCmd {   # open <issue>
    DEBUG($DEBUG_LOW, "reopenCmd()");
}


# remove existing issue
sub rmCmd {   # rm <issue>
    DEBUG($DEBUG_LOW, "rmCmd()");
}


# change default milestone or update milestones from existing issues
sub milestone {   # milestone | milestone [-u <old>] <mlst>
    DEBUG($DEBUG_LOW, "milestone()");
}


# print help screen
sub helpCmd { # help
    DEBUG($DEBUG_LOW, "helpCmd()");
    my ($error, $exitCode) = @_;

    if (defined($error)) {
        printf("error: $error\n\n");
    }

    printf("git-fool v0.1 (c) Manfred Hauser / git\@74th.de under the terms of GPL v3.0 or newer\n\n".
           "usage: git-fool <command> [option(s)]\n".
           "Commands:\n".
           "  init                         initialize git-fool within current git repository\n".
           "  new [-c|-p] <title>          create new issue (give -c(omment and parameters)\n".
           "                               or -p(parameters only)), title mustn't contain any slashes!\n".
           "  grep [-l] [<patterns>]       list all issues matching all given patterns (-l(ong))\n".                    # @todo: sortierung noch einbauen... simpel=nur nach issue, aufwändig=mit sortierangabe, z.B. i=issue, it=issue/type, ism=issue/state/milestone
           "                               without patterns all are shown\n".
           "                               escape characters if necessary, e.g. the dot and sth.\n".
           "                               it helps to use single quotation marks, e.g. '0\.3'\n".
           "                               comments aren't grepped but email addresses!\n".
           "  ls [<issue>]                 show given issue (without issue it will act like 'git-fool grep')\n".
           "                               given issue will be used as prefix of entries in issue file\n".
           "                               so it can be e.g. '1', '1/3D' and '1/3DES/git\@74th.de'\n".
           "  edit <issue>                 edit given 'open' issue\n".
           "  cp <issue>                   copies given issue and starts editing\n".                                    # @todo: beim kopieren evtl. original issue im title eintragen?
           "  close <issue>                set given issue to close\n".                                                 # @todo: Benutzer fragen, ob der eingegebene Milestone noch stimmt oder neuen eigeben lassen!
           "  open <issue>                 reopen given issue\n".
           "                               in most cases it's better to copy instead of reopening!\n".
           "  rm <issue>                   remove given issue from disk\n".                                             # @todo: anwender fragen ob er sich wirklich sicher ist
           "  milestone                    show current milestone\n".
           "  milestone [-u <old>] <mlst>  set new current milestone\n".
           "                               (-u(pdate) all open <old> MLSTs to <mlst>)\n".
           "  help                         show this help screen\n".
           "Settings (within git):\n".
           "  mandatory:\n".
           "    user.name                  developers name\n".
           "    user.email                 developers email\n".
           "  optional:\n".
           "    core.editor                for issue comment (default is 'vi')\n\n");

    if ($exitCode) {
        EXIT($exitCode);
    }
}


# just for testing...
sub dummyCmd {
    DEBUG($DEBUG_MED, "dummyCmd()");


}






#########################################
############## main() ###################
#########################################
my $cmd      = shift(@ARGV);    # first element of @ARGV is fool's command!

if (!defined($cmd)) {
    $cmd = "";
}
if ($cmd{$cmd}) {
    DEBUG($DEBUG_LOW, "valid command given");
    $cmd{$cmd}->(@ARGV);
}
else {
    DEBUG($DEBUG_LOW, "given command [$cmd] invalid");
    $cmd{"help"}->("missing or unknown command", 255);
}


1;

