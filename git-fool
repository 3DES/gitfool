#!/usr/bin/env perl

use strict;
use warnings;
use Git::Repository;
use Data::Dumper;
use Cwd;
use Getopt::Long;
use POSIX;
use Term::ReadKey;
use File::Path;


# debug stuff
my $DEBUG_NONE  = 0;
my $DEBUG_LOW   = 1;
my $DEBUG_MED   = 2;
my $DEBUG_HIGH  = 3;
my $DEBUG       = $DEBUG_NONE;


# defined issue types
my $ISSUE_TYPE_TASK     = 0;
my $ISSUE_TYPE_BUG      = 1;
my $ISSUE_TYPE_DEFAULT  = $ISSUE_TYPE_TASK;
# no duplicated issues here and no gaps between the issues!!!
my %ISSUE_TYPES = ( $ISSUE_TYPE_TASK    => "Task",
                    $ISSUE_TYPE_BUG     => "Bug",
                  );
my $ISSUE_TYPES_LENGTH = 4+2;       # means length("[Task]") = 4+2


# define states
my %ISSUE_STATES = ( "open"   => "open",
                     "closed" => "closed",
                   );
my $ISSUE_STATES_LENGTH = 6+2;      # means length("[closed]") = 6+2


# some necessary global variables
my $repo     = Git::Repository->new();


# some possibly necessary global variables (because of performance only filled when needed!)
my $mainPath          = "";         # git repository main path (where .git can be found)
my $foolPath          = "";         # $mainPath/.fool
my $userPath          = "";         # $foolPath/<user>  (= $mainPath/.fool/<user>)

my $userFile          = "";         # $userPath/<email> (= $mainPath/.fool/<user>/<email>)
my $issuesFile        = "";         # $foolPath/issues (= $mainPath/.fool/issues)

my $checkout          = "";         # current checkout

my $userName          = "";         # user.name
my $shortUserName     = "";         # first two characters of user.name (necessary for files and directories but not for issue file entry!)
my $email             = "";         # user.email
my $editor            = "";         # core.editor


# for cmd handling
my %cmd = ("init"      => \&initCmd,           # $cmd{"init"}->(...)
           "new"       => \&newCmd,
           "grep"      => \&grepCmd,
           "ls"        => \&lsCmd,
           "edit"      => \&editCmd,
           "cp"        => \&cpCmd,
           "close"     => \&closeCmd,
           "reopen"    => \&reopenCmd,
           "rm"        => \&rmCmd,
           "milestone" => \&milestoneCmd,
           "help"      => \&helpCmd,
           "dummy"     => \&dummyCmd,
          );


# define file names
my $FILE_NAME_ISSUES        = 0;
my $FILE_NAME_TEMP          = 1;
my $FILE_NAME_CURRENT_ISSUE = 2;
my $FILE_NAME_USER          = 3;
my %FILE_NAMES = ( $FILE_NAME_ISSUES            =>    "issues",
                   $FILE_NAME_TEMP              =>    ".temp",
                   $FILE_NAME_CURRENT_ISSUE     =>    "",              # to be created user name and email are necessary that are not known atm.
                   $FILE_NAME_USER              =>    "",              # to be created user name and email are necessary that are not known atm.
                  );



################################################
############## helper functions ################
################################################
# for a short periode of time CTRL+C should be disabled! @todo
#$SIG{INT} = \&mySIGINT;


sub mySIGINT() {
    printf("CTRL+C not allowed at the moment\n");
    $SIG{INT} = \&mySIGINT;
}


# debug outputs
sub DEBUG($$) {
    my ($level, $message) = @_;
    if ($DEBUG >= $level) {
        printf("DEBUG[$level]: $message\n");
    }
}


# extended exit function
sub EXIT($;$) {
    DEBUG($DEBUG_MED, "EXIT()");
    my ($exitCode, $message) = @_;

    if (defined($message)) {
        if ($exitCode) {
            printf("error: ");
        }
        printf("$message\n\n");
    }
    exit($exitCode);
}


# read user.name from git config
sub prepareUserName($) {
    DEBUG($DEBUG_MED, "prepareUserName()");
    my ($errorHandling) = @_;

    # only if $userName is not yet set because of performance reaseons!
    if (!$userName) {
        $userName = $repo->run("config" => "user.name");
        
        # user.name must be set to make git fool working!
        if (!$userName && $errorHandling) {
            EXIT(255, "user.name not set in git!");
        }
        $shortUserName = substr($userName, 0, 2);
        
        # if $shortUserName length is less than 2 $userName length is also less than two but two characters are our minimum so enlarge them!!!
        if (length($shortUserName) < 2) {
            $userName      .= "_";
            $shortUserName .= "_";
        }
    }
}


# read user.email from git config
sub prepareEmail($) {
    DEBUG($DEBUG_MED, "prepareEmail()");
    my ($errorHandling) = @_;

    # only if $email is not yet set because of performance reaseons!
    if (!$email) {
        $email    = $repo->run("config" => "user.email");
        if (!$email && $errorHandling) {
            EXIT(255, "user.email not set in git!");
        }
    }
}


# read core.editor from git config (environments, e.g. GIT_EDITOR will be ignored!)
sub prepareEditor() {
    DEBUG($DEBUG_MED, "prepareEditor()");

    # only if $editor is not yet set because of performance reaseons!
    if (!$editor) {
        $editor   = $repo->run("config" => "core.editor");
        if (!$editor) {
            $editor = "vi";
        }
    }
}


# read current checkout
sub prepareCheckout($) {
    DEBUG($DEBUG_MED, "prepareCheckout()");
    my ($errorHandling) = @_;
    
    if (!$checkout) {
        $checkout = $repo->run("rev-parse" => "HEAD");
        if (!$checkout && $errorHandling) {
            EXIT(255, "git-fool needs a valid checkout!");
        }
    }
}


# build git-fool system file name
sub getFileName($;@) {
    DEBUG($DEBUG_MED, "getFileName()");

    my ($fileType, @parameters) = @_;

    # expects getFileName(FILE_NAME_CURRENT_ISSUE, <latest issue value>)
    if ($fileType == $FILE_NAME_ISSUES) {
        if (scalar(@parameters) != 0) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }

        my $fileName = $FILE_NAMES{$fileType};
        return ($fileName, $foolPath."/".$fileName);
    }
    elsif ($fileType == $FILE_NAME_TEMP) {
        if (scalar(@parameters) != 0) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }

        my $fileName = $FILE_NAMES{$fileType};
        return ($fileName, $userPath."/".$fileName);
    }
    elsif ($fileType == $FILE_NAME_CURRENT_ISSUE) {
        if (scalar(@parameters) != 1) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }
        my ($latestValue) = @parameters;
        prepareUserName(1);
        prepareEmail(1);

        my $fileName = ".".join("_", ($latestValue, $userName, $email));
        return ($fileName, $foolPath."/".$fileName);
    }
    elsif ($fileType == $FILE_NAME_USER) {
        if (scalar(@parameters) != 0) {
            EXIT(254, "internal error - wrong amount of parameters: $fileType");
        }

        return ($email, $userPath."/".$email);
    }
    else {
        EXIT(254, "internal error - not handled file type: $fileType");
    }
}

# find main directory that contains ".git" and if initialization is already done also ".fool"
sub findRepoMainDir() {
    DEBUG($DEBUG_MED, "findRepoMainDir()");
    $mainPath = cwd();
    while (!(-d $mainPath."/.git")) {
        $mainPath = substr($mainPath, 0, rindex($mainPath, '/'));
        if (!$mainPath) {
            EXIT(255, "not inside a git repository!");
        }
    }
}


# fill $foolPath and $issuesFile variables
sub setFoolDir() {
    DEBUG($DEBUG_MED, "findFoolDir()");

    # get repo main path if not already set
    if (!$mainPath) {
        findRepoMainDir();
    }

    $foolPath   = $mainPath."/.fool";
    $issuesFile = getFileName($FILE_NAME_ISSUES);
}


# fill $userPath and $userFile variables
sub setUserDir() {
    DEBUG($DEBUG_MED, "findUserDir()");

    prepareEmail(1);
    prepareUserName(1);

    # get fool path if not already set
    if (!$foolPath) {
        setFoolDir();
    }

    $userPath    = $foolPath."/".$shortUserName;
    $userFile    = getFileName($FILE_NAME_USER);
}


# test if .fool directory exists
sub testFoolDir() {
    DEBUG($DEBUG_MED, "testFoolDir()");

    if (!$foolPath) {
        setFoolDir();
    }

    if (!(-d $foolPath) || !(-e $issuesFile)) {
        EXIT(255, "git-fool seems not to be initialized, run 'git-fool init'!");
    }
}


# test if .fool directory exists
sub testUserDir() {
    DEBUG($DEBUG_MED, "testUserDir()");

    if (!$userPath) {
        setUserDir();
    }

    if (!(-d $userPath) || !(-e $userFile)) {
        EXIT(255, "git-fool user path not initialized, run 'git-fool new'!");
    }
}


# prepare .fool directory
sub prepareFoolDir() {
    DEBUG($DEBUG_MED, "prepareFoolDir()");

    # find main directory of current repository and set $foolPath variable
    setFoolDir();

    # create .fool path if not exists
    if (!(-d $foolPath)) {
        mkdir($foolPath) || EXIT(255, "cannot create directory $foolPath: $!");
    }

    # create .fool/issues file if not exists
    if (!(-e getFileName($FILE_NAME_ISSUES))) {
        system("touch ".getFileName($FILE_NAME_ISSUES));
    }
}


# prepare .fool/<user> directory and .fool/<user>/<email> file
sub prepareUserDir() {
    DEBUG($DEBUG_MED, "prepareUserDir()");

    # find user directory
    setUserDir();

    # create user directory if not exists
    if (!(-d $userPath)) {
        mkpath($userPath) || EXIT(255, "cannot create directory $userPath: $!");;
    }

    # create .fool/<user>/latest if doesn't exist and fill it with 0 otherwise let it untouched
    if (!(-e $userFile)) {
        writeFile($userFile, ["0", "0.1"]);
    }
}


# create a new issue with given values and update .fool/<user>/.latest file
sub createNewIssue($$$$;$) {
    DEBUG($DEBUG_MED, "createNewIssue()");
    my ($latestValue, $issueType, $milestone, $title, $commentFile) = @_;

    # prepare necessary strings
    prepareEmail(1);
    prepareUserName(1);
    prepareCheckout(1);

    # if exists read comment file to be handled when comment/HISTORY file is written
    my %tagHash = ();
    if ($commentFile && -s $commentFile) {
        %tagHash = readTaggedFile($commentFile);
        system("rm $commentFile");
    }

    # create comment/history file
    if (!$tagHash{"[HISTORY]"}) {
        $tagHash{"[HISTORY]"} = [];
    }

    # now write current issue file (with comments and HISTORY)
    push(@{$tagHash{"[HISTORY]"}}, "created: ".strftime("%Z, %a %b %e %H:%M:%S %Y", localtime())." at $checkout");
    my ($currentIssueFileName, $currentIssueFile) = getFileName($FILE_NAME_CURRENT_ISSUE, $latestValue);
    writeTaggedFile($currentIssueFile, \%tagHash);

    # user info
    printf("created issue ".$currentIssueFileName);

    # write issue into issues file
    system("echo \"$latestValue/$userName/$email/$issueType/open/$milestone/$title\" >> $issuesFile");

    # update .fool/<user>/<email> file
    my @userFileContent = readFile($userFile);
    $userFileContent[0]++;
    writeFile($userFile, \@userFileContent);
}


# reads a string file into an array
sub readFile($) {
    DEBUG($DEBUG_MED, "readFile()");
    my ($fileName) = @_;

    my @fileContent = ();

    if (-e $fileName) {
        my $FH;
        open($FH, "<", $fileName) || EXIT(255, "cannot open $fileName: $!");
        while (<$FH>) {
            chomp($_);
            push(@fileContent, $_);
        }
        close($FH);
    }

    return @fileContent;
}


# writes content of a given array ref into a file
sub writeFile($\$) {
    DEBUG($DEBUG_MED, "writeFile()");
    my ($fileName, $linesRef) = @_;

    my $FH;
    open($FH, ">", $fileName) || EXIT(255, "cannot open $fileName: $!");

    foreach my $line (@{$linesRef}) {
        print($FH $line."\n");
    }
    close($FH);
}

# writes a given tag hash to a file (first writes optional leading tagless sections followed by optional tagged sections, tag means [<tag>])
sub writeTaggedFile($\$) {
    DEBUG($DEBUG_MED, "writeTaggedFile()");
    my ($fileName, $fileContentRef) = @_;

    # sub function for writing single body sections to prefent code duplication!
    my $subFunction = sub {
        my ($FH, $linesRef) = @_;

        my $lastLine = "";

        # now write all lines from current section
        foreach my $line (@{$linesRef}) {
            print($FH $line."\n");
            $lastLine = $line;
        }

        # ensure to have at least one empty line between sections
        if ($lastLine) {
            print($FH "\n");
        }
    };

    my $FH;
    open($FH, ">", $fileName) || EXIT(255, "cannot open $fileName: $!");

    # print tagless section (only body without any tag) at the beginning
    if (${$fileContentRef}{"none"}) {
        $subFunction->($FH, ${$fileContentRef}{"none"});
        delete(${$fileContentRef}{"none"});
    }

    # now print all other sections
    foreach my $key (sort(keys(%{$fileContentRef}))) {
        # print section tag
        print($FH $key."\n");
        my $lastLine = "";

        # print section body
        $subFunction->($FH, ${$fileContentRef}{$key});
    }

    close($FH);
}


# read whole tagged string file (means file with an optional leading tagless sections followed by optional tagged sections, tag means [<tag>])
sub readTaggedFile($) {
    DEBUG($DEBUG_MED, "readTaggedFile()");
    my ($fileName) = @_;

    my @lines = readFile($fileName);

    my %tagContent = ("none" => []);

    my $currenTag = "none";
    foreach my $line (@lines) {
        chomp($line);

        # tag line found?
        if ($line =~ /^\[([^]]+)\]$/) {
            $currenTag = $1;
            $tagContent{$currenTag} = [];           # create new tag entry in tag hash
            next;                                   # line handled take next one
        }

        push(@{$tagContent{$currenTag}}, $line);    # if not a tag line push it into current tag content array
    }

    return %tagContent;
}


# if given string is longer than given size string will be cut and an ellipse will be added
sub shortenString($$) {
    DEBUG($DEBUG_MED, "shortenString()");
    my ($string, $size) = @_;

    if (length($string) > $size) {
        $string = substr($string, 0, $size-3)."...";
    }

    return $string;
}


#
sub printIssue($$$) {
    DEBUG($DEBUG_MED, "printIssue()");
    my ($line, $long, $alreadyWritten) = @_;

    my ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();

    # some variables to make later changes little bit easier!
    my $milestoneLength   = 9;
    my $idLength          = 6;
    my $userNameLength    = 10;
    my $defaultTileLength = 35;
    my $maxTitleLength    = $wchar - 50; # depends on window size
    if ($maxTitleLength < 10) {
        $maxTitleLength = $defaultTileLength;   # if window is too small for printing the title ignore window size and print the whole title
    }

    # issue line has to be printed
    if ($line =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/) {
        # process with line elements
        my ($id, $userName, $email, $issueType, $state, $milestone, $title) = ($1, $2, $3, $4, $5, $6, $7);

        # do some string formattings (to shorten the output to screen width if not option -l is used!)
        my $userNamePrepared  =      shortenString($userName,           $userNameLength);
        my $titlePrepared     = "\"".shortenString($title,              $maxTitleLength-2)     ."\"";      # -2 because of the quotation marks "<text>"
        my $issueTypePrepared =      shortenString($issueType,          $ISSUE_TYPES_LENGTH);
        my $statePrepared     =      shortenString($state,              $ISSUE_STATES_LENGTH);
        my $milestonePrepared = "\"".shortenString($milestone,          $milestoneLength-2)    ."\"";      # -2 because of the brackets [<MLST>]

        # now print the stuff
        if (!$long) {   # print each issue into one line as long as the window is not too smal otherwise line will be printed uncut (see calculation of $maxTitleLength)
            # if not -l print a header line
            if (!$alreadyWritten) {
                printf("%-".($idLength+$userNameLength+1)."s %-".$maxTitleLength."s %-".$ISSUE_TYPES_LENGTH."s %-".$ISSUE_STATES_LENGTH."s %s\n", "ISSUE", "TITLE", "TYPE", "STATE", "MILESTONE");
                printf(("-" x (45+$maxTitleLength))."\n");
            }

            printf("%-".($idLength+$userNameLength+1)."s %-".$maxTitleLength."s %-".$ISSUE_TYPES_LENGTH."s %-".$ISSUE_STATES_LENGTH."s %s\n", "".$id."\/".$userNamePrepared, $titlePrepared, $issueTypePrepared, $statePrepared, $milestonePrepared);
        }
        else {          # if -l parameter is given the issue line is printed uncut in any case
            # if this is not the first line to be printed print a ############### separator line
            if ($alreadyWritten) {
                printf(("#" x (45+$maxTitleLength))."\n\n");
            }

            # now print header line
            printf("Issue ....... %s\n".
                   "Email ....... %s\n".
                   "Title ....... %s\n".
                   "Type ........ %s\n".
                   "State ....... %s\n".
                   "Milestone ... %s\n\n", "".$id."\/".$userName, $email, $title, $issueType, $state, $milestone);

            # now try to print the comment/HISTORY file
            my $currentIssueFile   = getFileName($FILE_NAME_CURRENT_ISSUE, $id);
            my @commentHistoryFile = readFile($currentIssueFile);
            foreach my $line (@commentHistoryFile) {
                printf("$line\n");
            }
        }
    }
    else {
        EXIT(255, "found damaged line in issue file: [$line]");
    }
}




################################################
############## fool commands ###################
################################################


# initialize git repository for git-fool (.fool folder will be created)
sub initCmd() {
    DEBUG($DEBUG_LOW, "initCmd()");

    # prepare fool dir if necessary
    prepareFoolDir();
}


# create new issue
sub newCmd() {  # new [-c|-p] <title>
    DEBUG($DEBUG_LOW, "newCmd()");
    my @arguments = @_;

    # check command arguments
    if (scalar(@arguments) < 1 || (scalar(@arguments) == 1 && ($arguments[0] eq "-c" || $arguments[0] eq "-p"))) {
        $cmd{"help"}->("'git-fool new' parameters mismatch", 255);
    }

    testFoolDir();      # check if .fool directory exists (if not init hasn't be called yet!)
    prepareUserDir();   # may be we have to create the user directory if this is the first time current user calls 'new' command

    # reading latest issue value from file (file contains only this one line!)
    my @userFileContent = readFile($userFile);
    my $userLatestValue = $userFileContent[0];
    my $userMilestone   = $userFileContent[1];

    if ($userLatestValue !~ /^[0-9]+$/) {
        EXIT(255, "$userFile contains invalid latest value!");
    }
    $userLatestValue++; # increment for current issue

    # reading milestone value from file (file contains only this one line!)
    if (!$userMilestone) {
        EXIT(255, "$userFile contains invalid milestone value!");
    }

    my $tempFile  = "";
    my $issueType = $ISSUE_TYPE_DEFAULT;

    if ($arguments[0] eq "-c" || $arguments[0] eq "-p") {
        # reading milestrom from user input
        printf("Milestone [$userMilestone]: ");     # pressing just [ENTER] doesn't change default milestone
        my $newUserMilestone = <STDIN>;   # read new milestone
        chomp($newUserMilestone);
        if ($newUserMilestone) {
            $userMilestone = $newUserMilestone;
        }

        # reading issue type from user input
        printf("issue type: ");
        my $counter = 1;
        foreach my $issue (sort(keys(%ISSUE_TYPES))) {
            printf("$issue-$ISSUE_TYPES{$issue}");
            if ($counter++ < scalar(keys(%ISSUE_TYPES))) {
                printf(", ");
            }
            else {
                printf(" [$issueType]: ");  # print default option if user presses just [ENTER]
            }
        }
        my $newIssueType = <STDIN>;
        chomp($newIssueType);
        if ($newIssueType =~ /^[0-9]+$/ && $newIssueType >= 0 && $newIssueType < scalar(keys(%ISSUE_TYPES))) {
            $issueType = $newIssueType;
        }

        if ($arguments[0] eq "-c") {
            prepareEditor();
            $tempFile = getFileName($FILE_NAME_TEMP);
            system("echo -n > $tempFile");      # ensure that .fool/<user>/.temp exists and is empty!
            system("$editor $tempFile");        # open editor to edit temp file
        }

        shift(@arguments);      # remove cmd from arguments list because rest is the issue title
    }

    createNewIssue($userLatestValue, $ISSUE_TYPES{$issueType}, $userMilestone, join(" ", @arguments), $tempFile);
}


# create new issue
sub grepCmd() {   # grep [-l] [<pattern>]
    DEBUG($DEBUG_LOW, "grepCmd()");
    my @arguments = @_;

    my $long = 0;

    # check command arguments
    if (@arguments && $arguments[0] eq "-l") {
        $long = 1;
        shift(@arguments);
    }

    # test if init has already be done
    testFoolDir();

    # read issues file
    my @issuesFileContent = readFile($issuesFile);

    # now handle all issues' lines
    my $alreadyWritten = 0;
    foreach my $line (@issuesFileContent) {
        # if <patterns> are given we have to match...
        my $patternFound = 0;
        if (@arguments) {
            foreach my $pattern (@arguments) {
                if ($line =~ /$pattern/) {
                    $patternFound = 1;
                    last;
                }
            }
            next unless ($patternFound);    # if no pattern matched continue with next line...
        }

        printIssue($line, $long, $alreadyWritten);
        $alreadyWritten = 1;
    }
}


# create new issue
sub lsCmd() { # ls [<issue>]
    DEBUG($DEBUG_LOW, "lsCmd()");
    my @arguments = @_;

    # check command arguments
    if (@arguments > 1) {
        $cmd{"help"}->("'git-fool ls' parameters mismatch", 255);
    }
    if (!@arguments) {
        grepCmd();
        return;
    }

    # test if init has already be done
    testFoolDir();

    # read issues file
    my @issuesFileContent = readFile($issuesFile);

    # search and if found handle issue
    foreach my $line (@issuesFileContent) {
        if ($line =~ /^$arguments[0]/) {
            printIssue($line, 1, 0);
            return;
        }
    }
    
    printf("given issue [$arguments[0]] couldn't be matched\n");
}


# create new issue
sub editCmd() { # edit <issue>
    DEBUG($DEBUG_LOW, "editCmd()");
    my @arguments = @_;

    # check command arguments
    if (@arguments != 1 || $arguments[0] !~ /^[0-9]+$/) {
        $cmd{"help"}->("'git-fool edit' parameters mismatch", 255);
    }

    # test if init has already be done
    testFoolDir();

    # read issues file
    my @issuesFileContent = readFile($issuesFile);

    # prepare necessary strings
    prepareEmail(1);
    prepareUserName(1);
    prepareCheckout(1);

    # search for given issue in issue file
    my $lineIndex;
    for ($lineIndex = 0; $lineIndex<@issuesFileContent; $lineIndex++) {
        if ($issuesFileContent[$lineIndex] =~ /^([^\/]+)/) {
            # process with line elements
            if ($1 == $arguments[0]) {
                last;
            }
        }
    }
    if ($lineIndex == @issuesFileContent) {
        EXIT(255, "given issue doesn't exist!");
    }

    printIssue($issuesFileContent[$lineIndex], 0, 0);
    printf("\n");

    # set to 1 if anything of the issue has been changed!
    my $issueChanged = 0;

    # now scan and handle line
    my $line = $issuesFileContent[$lineIndex];
    if ($line =~ /^([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/) {
        # process with line elements
        my ($id, $userName, $email, $issueType, $state, $milestone, $title) = ($1, $2, $3, $4, $5, $6, $7);

        # reading milestrom from user input
        printf("Milestone [$milestone]: ");     # pressing just [ENTER] doesn't change default milestone
        my $newMilestone = <STDIN>;   # read new milestone
        chomp($newMilestone);
        if ($newMilestone) {
            $milestone = $newMilestone;
            $issueChanged = 1;
        }

        # find issue type string and convert it into issue type value
        while (my($key, $value) = each %ISSUE_TYPES) {
            if ($value eq $issueType) {
                $issueType = $key;
                last;
            }
        }
        # reading issue type from user input
        printf("issue type: ");
        my $counter = 1;
        foreach my $issue (sort(keys(%ISSUE_TYPES))) {
            printf("$issue-$ISSUE_TYPES{$issue}");
            if ($counter++ < scalar(keys(%ISSUE_TYPES))) {
                printf(", ");
            }
            else {
                printf(" [$issueType]: ");  # print default option if user presses just [ENTER]
            }
        }
        my $newIssueType = <STDIN>;
        chomp($newIssueType);
        if ($newIssueType =~ /^[0-9]+$/ && $newIssueType >= 0 && $newIssueType < scalar(keys(%ISSUE_TYPES))) {
            $issueType = $newIssueType;
            $issueChanged = 1;
        }

        # reading new title from user input
        printf("Title [$title]:\n");    # pressing just [ENTER] doesn't change original title
        my $newTitle = <STDIN>;         # read new title
        chomp($newTitle);
        if ($newTitle) {
            $title = $newTitle;
            $issueChanged = 1;
        }

        # read tagged file
        my ($currentIssueFileName, $currentIssueFile) = getFileName($FILE_NAME_CURRENT_ISSUE, $arguments[0]);

        print $currentIssueFile;



#hier gehts weiter..........
#        xxxxxxxxxxx
#        readfile
#        create temp file
#        after change read temp file
#        beide none sections vergleichen        -> $issueChanged = 1;
#        beide files zusammenhängen
#        file überschreiben


#        my %tagHash = ();
#        if ($commentFile && -s $commentFile) {
#            %tagHash = readTaggedFile($commentFile);
#            system("rm $commentFile");
#        }
#    
#    
#    
#        my ($currentIssueFileName, $currentIssueFile) = getFileName($FILE_NAME_CURRENT_ISSUE, $latestValue);
#        writeTaggedFile($currentIssueFile, \%tagHash);
#    
#    
#    
#        # write issue into issues file
#        system("echo \"$latestValue/$userName/$email/$issueType/open/$milestone/$title\" >> $issuesFile");
#





#        prepareEditor();
#        $tempFile = getFileName($FILE_NAME_TEMP);
#        system("echo -n > $tempFile");      # ensure that .fool/<user>/.temp exists and is empty!
#        system("$editor $tempFile");        # open editor to edit temp file




    }
    else {
        EXIT(255, "found damaged line in issue file: [$line]");
    }
}


# create new issue
sub cpCmd() {   # cp <issue>
    DEBUG($DEBUG_LOW, "cpCmd()");
}


# create new issue
sub closeCmd() {    # close <issue>
    DEBUG($DEBUG_LOW, "closeCmd()");
}


# create new issue
sub reopenCmd() {   # open <issue>
    DEBUG($DEBUG_LOW, "reopenCmd()");
}


# create new issue
sub rmCmd() {   # rm <issue>
    DEBUG($DEBUG_LOW, "rmCmd()");
}


# create new issue
sub milestone() {   # milestone [[-u] <text>]
    DEBUG($DEBUG_LOW, "milestone()");
}


# print help screen
sub helpCmd() { # help
    DEBUG($DEBUG_LOW, "helpCmd()");
    my ($error, $exitCode) = @_;

    if (defined($error)) {
        printf("error: $error\n\n");
    }

    printf("git-fool v0.1 (c) Manfred Hauser / git\@74th.de under the terms of GPL v3.0 or newer\n\n".
           "usage: git-fool <command> [option(s)]\n".
           "Commands:\n".
           "  init                         initialize git-fool within current git repository\n".
           "  new [-c|-p] <title>          create new issue (give -c(omment and parameters)\n".
           "                               or -p(parameters only)), title mustn't contain any slashes!\n".
           "  grep [-l] [<patterns>]       list all issues matching at least one given pattern (-l(ong))\n".
           "                               comments are not grepped!\n".
           "  ls [<issue>]                 show given issue (without issue it will act like 'git-fool grep')\n".
           "                               given issue will be used as prefix of entries in issue file\n".
           "                               so it can be e.g. '1', '1/3D' and '1/3DES7git\@74th.de'\n".
           "  edit <issue>                 edit given 'open' issue\n".
           "  cp <issue>                   copies given issue and starts editing\n".
           "  close <issue>                set given issue to close\n".
           "  open <issue>                 reopen given issue\n".
           "  rm <issue>                   remove given issue from disk\n".
           "  milestone                    show current milestone\n".
           "  milestone [-u <old>] <mlst>  set new current milestone\n".
           "                               (-u(pdate) all open <old> MLSTs to <mlst>)\n".
           "  help                         show this help screen\n".
           "Settings (within git):\n".
           "  mandatory:\n".
           "    user.name                  developers name\n".
           "    user.email                 developers email\n".
           "  optional:\n".
           "    core.editor                for issue comment (default is 'vi')\n\n");

    if ($exitCode) {
        EXIT($exitCode);
    }
}


# just for testing...
sub dummyCmd() {
    DEBUG($DEBUG_MED, "dummyCmd()");


}






#########################################
############## main() ###################
#########################################
my $cmd      = shift(@ARGV);    # first element of @ARGV is fool's command!

if (!defined($cmd)) {
    $cmd = "";
}
if ($cmd{$cmd}) {
    DEBUG($DEBUG_LOW, "valid command given");
    $cmd{$cmd}->(@ARGV);
}
else {
    DEBUG($DEBUG_LOW, "given command [$cmd] invalid");
    $cmd{"help"}->("missing or unknown command", 255);
}


1;

